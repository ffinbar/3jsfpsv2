<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <title>Three.js Project</title>
    <style>
         .material-symbols-outlined {
          font-variation-settings:
          'FILL' 1,
          'wght' 400,
          'GRAD' 0,
          'opsz' 24
        }

        * {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body { margin: 0; }
        canvas { display: block; }

        h1 {
            font-size: 2em;
            margin-bottom: 1em;
        }

        #overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            background: transparent;
            border: none;
            border-radius: 50%;
            z-index: 2;
            margin-left: -5px;
            margin-top: -5px;
            
        }

        #chchar {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5em;
            color: #ffffffb3;
            /* text-shadow: 0 0 2px #000000; */
        }

        #pauseMenu {
            position: absolute;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: all;
        }

        #pauseMenu section {
            display: flex;
            flex-direction: column;
            background: #00000082;
            color: white;
            padding: 2em;
            max-width: 40vw;
            max-height: 80vh;
            overflow-y: auto;
            width: 100%;
            border-radius: 1em;
            box-shadow: 0 0 10px 0 #00000082;
        }

        #pauseMenu section button {
            margin: 0.5em;
            padding: 0.5em;
            border: none;
            background: #00000082;
            color: white;
            font-size: 1.5em;
            cursor: pointer;
        }

        #pauseMenu section p {
            margin: 0.5em;
            font-size: 1.2em;
        }

        #pauseMenu section button:hover {
            background: #000000a1;
        }

        #pauseMenu section button:active {
            background: #000000c1;
        }

        #settingsList {
            display: flex;
            flex-direction: column;
            gap: 1em;
            font-size: 1.2em;
        }

        select, input[type="range"] {
            width: 100%;
        }

        select {
            padding: 0.5em;
        }

    </style>
</head>
<body>
    <div id="pauseMenu">
        <section id="pauseDefault">
            <h1>Paused</h1>
            <button id="resume">Resume</button>
            <button id="settings">Settings</button>
            <button id="controls">Controls</button>
            <button id="restart">Restart</button>
        </section>
        <section id="settingsMenu" style="display: none;">
            <h1>Settings</h1>
            <div id="settingsList">
                <!-- <label for="sensitivity">Mouse Sensitivity: <span id="sensitivityValue">0.5</span></label>
                <input type="range" id="sensitivity" min="0.1" max="1" step="0.1" value="0.5"> -->
                <h2>Presets</h2>
                <label for="quality">Quality</label>
                <select id="quality">
                    <option value="high">High</option>
                    <option value="medium">Medium</option>
                    <option value="low">Low</option>
                </select>

                <h2>Player</h2>
                <label for="moveSpeed">Move Speed: <span id="moveSpeedValue">0.5</span></label>
                <input type="range" id="moveSpeed" min="0" max="10" step="0.5" value="0.5">
                
                <label for="jumpHeight">Jump Height: <span id="jumpHeightValue">15</span></label>
                <input type="range" id="jumpHeight" min="0" max="50" step="1" value="15">

                <h2>World</h2>
                <label for="dayLength">Day Length (minutes): <span id="dayLengthValue">3</span></label>
                <input type="range" id="dayLength" min="0.5" max="10" step="0.5" value="3">
                
                <h2>Graphics</h2>
                <label for="fov">Field of View: <span id="fovValue">85</span></label>
                <input type="range" id="fov" min="30" max="120" step="1" value="85">
                
                <label for="bloomStr">Bloom Strength: <span id="bloomStrValue">0.2</span></label>
                <input type="range" id="bloomStr" min="0" max="3" step="0.1" value="0.2">

                <label for="bloomRadius">Bloom Radius: <span id="bloomRadiusValue">1</span></label>
                <input type="range" id="bloomRadius" min="0" max="3" step="0.1" value="1">

                <label for="bloomThreshold">Bloom Threshold: <span id="bloomThresholdValue">2.6</span></label>
                <input type="range" id="bloomThreshold" min="0" max="3" step="0.1" value="2.6">
                
                <label for="exposure">Exposure: <span id="exposureValue">0.3</span></label>
                <input type="range" id="exposure" min="0" max="1" step="0.1" value="0.3">

                <label for="environmentUpdateSpeed">Environment Update Speed (seconds): <span id="environmentUpdateSpeedValue">0.3</span></label>
                <input type="range" id="environmentUpdateSpeed" min="0" max="10.1" step="0.1" value="0.3">
                
                
                
                <label for="shadows">Shadows</label>
                <select id="shadows">
                    <option value="high">High</option>
                    <option value="medium">Medium</option>
                    <option value="low">Low</option>
                    <option value="off">Off</option>
                </select>
                
            </div>
            <button class="back">Back</button>
        </section>
        <section id="controlsList" style="display: none;">
            <h1>Controls</h1>
            <div>
                <p>Use WASD to move</p>
                <p>Space to jump</p>
                <p>C to crouch</p>
                <p>Press E when you see <span class="material-symbols-outlined">pan_tool</span> to grab an object</p>
                <p>Press E again to release the object</p>
                <p>Scrolling while holding an object will move it closer or further away</p>
                <p>Press F for flashlight</p>
            </div>
            <button class="back">Back</button>
        </section>
        
    </div>

    <script>
        


    </script>

    <div id="overlay">
        
        <span id="chchar" class="material-symbols-outlined" style="display: none;">
        fiber_manual_record
        </span>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
                "cannon-es": "https://unpkg.com/cannon-es/dist/cannon-es.js"
            }

        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es'
        import CannonDebugger from './node_modules/cannon-es-debugger/dist/cannon-es-debugger.js';
        // import { OrbitControls } from './node_modules/three/examples/jsm/controls/OrbitControls.js';
        import { PointerLockControlsCannon } from './pointerLockControlsCannon.js';
        import Stats from './node_modules/three/examples/jsm/libs/stats.module.js';
        import { GLTFLoader } from './node_modules/three/examples/jsm/loaders/GLTFLoader.js';
        import {threeToCannon, ShapeType} from './node_modules/three-to-cannon/dist/three-to-cannon.modern.js';
        import { EffectComposer } from './node_modules/three/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from './node_modules/three/examples/jsm/postprocessing/RenderPass.js';
        import { OutlinePass } from './node_modules/three/examples/jsm/postprocessing/OutlinePass.js';
        import { OutputPass } from './node_modules/three/examples/jsm/postprocessing/OutputPass.js';
        import { Sky } from './node_modules/three/examples/jsm/objects/Sky.js'
        import { GUI } from './node_modules/three/examples/jsm/libs/lil-gui.module.min.js'
        import {GLTFExporter} from './node_modules/three/examples/jsm/exporters/GLTFExporter.js';
        import {ImprovedNoise } from './node_modules/three/examples/jsm/math/ImprovedNoise.js';
        import { UnrealBloomPass } from './node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js';

        const width = window.innerWidth, height = window.innerHeight;

        let isPaused = true;

        let timeStep = 1 /60; // seconds
        let lastCallTime = performance.now() /1000
        let pausedTime = 0
        let pauseStartTime;

        let dayLength = 3*60;

        let scene, camera, renderer, composer, controls, stats, outlinePass = {};
        let currentRenderer = renderer;
        let bloomPass;
        outlinePass.selectedObjects = [];
        let sunLight, sunTarget, sunHelper;
        let sky, sun;
        let sunUpdateInterval;
        let defaultMaterial, defaultGeometry, defaultRadius;
        let world, cannonDebugger;
        let slipMaterial;
        let player = {};
        let playerBody, playerMesh, playerShape, playerMaterial;
        let isGrabbing = false;
        let moveSpeed = 10;
        let grabbedObject = null;
        let grabBody = {};
        let yawBody, handBody;
        let grabConstraint, jointBody;

        let crosshairStates = {
            look: 'fiber_manual_record',
            grab: 'pan_tool',
            interact: 'touch_app',
            none: 'block'
        }

        let pauseMenu = document.getElementById('pauseMenu');
        let menuDefault = document.getElementById('pauseDefault'), 
        resumeBtn = document.getElementById('resume'),
        settingsBtn = document.getElementById('settings'),
        controlsBtn = document.getElementById('controls'), 
        restartBtn = document.getElementById('restart'),
        settingsMenu = document.getElementById('settingsMenu'),
        controlsList = document.getElementById('controlsList'),
        backBtns = document.querySelectorAll('.back'),
        crosshair = document.getElementById('chchar');

        let settings = {};

        let scrollDirection = 0; // 0: no scroll, 1: scroll up, -1: scroll down

        let mixers = [];

        const PLAYER_GROUP = 1 << 0; // 0001 in binary
        const EVERYTHING_ELSE_GROUP = 1 << 1; // 0010 in binary

        let starMesh, starMaterial;
        let cubeCamera, cubeRenderTarget;

        let spotLight, spotLightHelper, spotLightTarget;

        let keys = {};

        const meshMap = new Map();
        
        init();

        async function init() {
            settingsSetup();

            // init
            sceneSetup();
            cameraSetup();
            rendererSetup();

            setCrosshair('look');
            
            statsSetup();
            physicsSetup();
            createObjects();
            lightSetup();
            
            
            
            inputSetup();
            createPlayer();
            controlsSetup();
            skySetup();
            let sceneGltf = await loadGLTF('assets/coltesting.glb', 1)
            scene.add(sceneGltf.scene);

            // carSetup();
            
        }

        function settingsSetup() {
            // settingsList setup
            const settingsList = document.getElementById('settingsList');
            settings = {}

            settingsList.querySelectorAll('input, select').forEach(setting => {
            settings[setting.id] = setting;
            });

            console.log(settings)

            for (const setting in settings) {
                settings[setting].addEventListener('input', () => {
                    updateSetting(setting);
                }) 
            }

            //player

            settings.moveSpeed.addEventListener('input', () => {
            updateMoveSpeed();
            })

            settings.jumpHeight.addEventListener('input', () => {
            updateJumpHeight();
            })

            //

            settings.dayLength.addEventListener('input', () => {
            updateDayLength();
            })

            settings.fov.addEventListener('input', () => {
            updateFov();
            })

            settings.bloomStr.addEventListener('input', () => {
            updateBloomSettings(parseFloat(settings.bloomStr.value), null, null);
            })

            settings.bloomRadius.addEventListener('input', () => {
            updateBloomSettings(null, parseFloat(settings.bloomRadius.value), null);
            })

            settings.bloomThreshold.addEventListener('input', () => {
            updateBloomSettings(null, null, parseFloat(settings.bloomThreshold.value));
            })

            settings.exposure.addEventListener('input', () => {
            updateExposure(parseFloat(settings.exposure.value));
            })

            settings.environmentUpdateSpeed.addEventListener('input', () => {
            updateEnvironmentUpdateSpeed(settings.environmentUpdateSpeed.value);
            })

            settings.quality.addEventListener('input', () => {
                switch (settings.quality.value) {
                    case 'high':
                        renderer.shadowMap.enabled = true;
                        bloomPass.enabled = true;
                        updateEnvironmentUpdateSpeed(0.3);
                        currentRenderer = composer;
                        sunLight.shadow.mapSize.width = 2048
                        sunLight.shadow.mapSize.height = 2048
                        break;
                    case 'medium':
                        renderer.shadowMap.enabled = true;
                        bloomPass.enabled = true;
                        updateEnvironmentUpdateSpeed(3);
                        currentRenderer = composer;
                        sunLight.shadow.mapSize.width = 1024
                        sunLight.shadow.mapSize.height = 1024
                        break;
                    case 'low':
                        renderer.shadowMap.enabled = false;
                        bloomPass.enabled = false;
                        updateEnvironmentUpdateSpeed(10.1);
                        currentRenderer = renderer;
                        sunLight.shadow.mapSize.width = 512;
                        sunLight.shadow.mapSize.height = 512;

                        break;
                }
                currentRenderer === composer ? composer.render() : renderer.render(scene, camera);
            })
        }

        function updateSetting(setting) {
            //if not a select element
            if (settings[setting].type !== 'select-one') {
            document.getElementById(`${setting}Value`).textContent = settings[setting].value;
            }
        }

        function updateMoveSpeed(overrideValue = null) {
            moveSpeed = overrideValue !== null ? parseFloat(overrideValue) : parseFloat(settings.moveSpeed.value);
            if(controls) {
            controls.velocityFactor = moveSpeed;
            console.log(controls.velocityFactor)
            }
        }

        function updateJumpHeight(overrideValue = null) {
            controls.jumpVelocity = overrideValue !== null ? parseFloat(overrideValue) : parseFloat(settings.jumpHeight.value);
        }

        function updateDayLength(overrideValue = null) {
            dayLength = overrideValue !== null ? parseFloat(overrideValue) * 60 : parseFloat(settings.dayLength.value) * 60;
        }

        function updateFov(overrideValue = null) {
            camera.fov = overrideValue !== null ? parseFloat(overrideValue) : parseFloat(settings.fov.value);
            camera.updateProjectionMatrix();
            if(composer) {
            composer.setSize(window.innerWidth, window.innerHeight);
            composer.render();
            }
        }

        function updateBloomSettings(strength = null, radius = null, threshold = null) {
            if (strength !== null) {
            bloomPass.strength = strength;
            }
            if (radius !== null) {
            bloomPass.radius = radius;
            }
            if (threshold !== null) {
            bloomPass.threshold = threshold;
            }
            composer.render();
        }

        function updateExposure(overrideValue = null) {
            renderer.toneMappingExposure = overrideValue !== null ? parseFloat(overrideValue) : parseFloat(settings.exposure.value);
            composer.render();
        }

        function updateEnvironmentUpdateSpeed(overrideValue = null) {
            let value = overrideValue !== null ? overrideValue : parseFloat(settings.environmentUpdateSpeed.value);

            if(sunUpdateInterval && cubeCamera) {
            if(value == 10.1) {
                clearInterval(sunUpdateInterval);
                document.getElementById(`environmentUpdateSpeedValue`).textContent = 'Off';
            } else {
                clearInterval(sunUpdateInterval);
                sunUpdateInterval = setInterval(function() {
                cubeCamera.update(renderer, scene)
                }, value * 1000);
            }
            }
        }

        
        function setCrosshair(state) {
            crosshair.textContent = crosshairStates[state];
        }

        function resume() {
            controls.lock();
            // pauseStartTime = performance.now();
            
            
        }

        function sceneSetup() {
            // scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color( 0x87ceeb );

            scene.fog = new THREE.Fog( 0x87ceeb, 1, 1000 );

        }

        function cameraSetup() {
            // camera
            camera = new THREE.PerspectiveCamera( 85, width / height, 0.01, 100 );
           
            camera.lookAt(0, 0, 0);

            player.hand = new THREE.Object3D();
            camera.add(player.hand);
            player.hand.position.set(0, 0, -3);
            
            player.anim = {};

            player.anim.grabDest = new THREE.Object3D();
            camera.add(player.anim.grabDest);
            player.anim.grabDest.position.set(0, 0, -1);
        }

        function rendererSetup() {
            // renderer
           
            renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.setAnimationLoop( animate );
            renderer.outputEncoding = THREE.sRGBEncoding;
            
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.VSMShadowMap;

            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.3;
            
            document.body.appendChild( renderer.domElement );

            
            composer = new EffectComposer(renderer);
            currentRenderer = composer;
            composer.addPass(new RenderPass(scene, camera));

            bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.2, 1, 2.6);
            composer.addPass(bloomPass);

            // outlinePass = new OutlinePass(new THREE.Vector2(1, 1), scene, camera);
            // outlinePass.edgeStrength = 3.0;
            // outlinePass.edgeGlow = 1.0;
            // outlinePass.edgeThickness = 1.0;
            // outlinePass.pulsePeriod = 0;
            // outlinePass.usePatternTexture = false;
            // outlinePass.visibleEdgeColor.set('#ffffff');
            // outlinePass.hiddenEdgeColor.set('#190a05');
            // composer.addPass(outlinePass);
        
            const outputPass = new OutputPass();
            composer.addPass(outputPass);
        }

        function lightSetup() {
            // lights
            // const light = new THREE.DirectionalLight( 0xffffff, 1 );
            // light.position.set( 5, 5, 5 );
            // light.castShadow = true;
            // light.shadow.mapSize.width = 1024;
            // light.shadow.mapSize.height = 1024;
            // light.shadow.camera.near = 0.5;
            // light.shadow.camera.far = 500;

            // scene.add( light );

            // const ambientLight = new THREE.AmbientLight( 0xffffff, 0.5 );
            // scene.add( ambientLight );

            sunLight = new THREE.DirectionalLight(0xFFFFFF, 5);
            sunLight.position.set(5, 10, 5);
            sunLight.castShadow = true;
            sunLight.shadow.bias = -0.0001;
            const size = 100; 
            sunLight.shadow.camera.left = -size;
            sunLight.shadow.camera.right = size;
            sunLight.shadow.camera.top = size;
            sunLight.shadow.camera.bottom = -size;
            sunLight.shadow.mapSize.width = 2048; // Default is 512
            sunLight.shadow.mapSize.height = 2048; // Default is 512
            // sunLight.shadow.radius = 1;

            sunTarget = new THREE.Object3D();
            sunTarget.position.set(0, 0, 0);

            spotLightTarget = new THREE.Object3D();
            spotLightTarget.position.set(0, 0, -13);
            camera.add(spotLightTarget);


            sunLight.target.position.set(sunTarget.position.x, sunTarget.position.y, sunTarget.position.z);
            scene.add(sunLight);

            let debugSun = new THREE.DirectionalLight(0xFFFFFF, 3);
            debugSun.position.set(5, 10, 5);
            // debugSun.target = (new THREE.Object3D()).position.set(0, 0, 0);
            // scene.add(debugSun);

            // sunHelper = new THREE.DirectionalLightHelper(sunLight, 5);
            // scene.add(sunHelper);

            spotLight = new THREE.SpotLight(0xFFFFFF, 0);
            spotLight.position.set(0, 0, -0.1);
            spotLight.target = spotLightTarget;
            spotLight.angle = Math.PI / 4;
            spotLight.penumbra = 0.3;
            spotLight.decay = 0.7;
            spotLight.distance = 10;

            spotLight.castShadow = false;

            camera.add(spotLight);

            

            // spotLightHelper = new THREE.SpotLightHelper(spotLight);
            // scene.add(spotLightHelper);


        }

        function skySetup() {
            sky = new Sky();
            sky.scale.setScalar( 450000 );
            scene.add( sky );
            

            sun = new THREE.Vector3();


            cubeRenderTarget = new THREE.WebGLCubeRenderTarget( 16 );
            cubeRenderTarget.texture.type = THREE.HalfFloatType;

            cubeCamera = new THREE.CubeCamera( 100, 100, cubeRenderTarget );
            
            //

            let material = new THREE.MeshStandardMaterial( {
                envMap: cubeRenderTarget.texture,
                roughness: 0,
                metalness: 1
            } );

            const geometry = new THREE.SphereGeometry( 1, 8, 8 );
            const mesh = new THREE.Mesh( geometry, material );
            scene.add( mesh );
            mesh.position.set(0, 20, 0);
            cubeCamera.position.copy( mesh.position );
            scene.environment = cubeRenderTarget.texture;

            // stars setup
            //material:

            const starCanvas = document.createElement( 'canvas' );
            starCanvas.width = 1012;
            starCanvas.height = 1012;
            const starCtx = starCanvas.getContext( '2d' );

            // draw stars
            for (let i = 0; i < 5000; i++) {
                const x = Math.random() * starCanvas.width;
                const y = Math.random() * starCanvas.height;
                const size = Math.random() * 0.1;
                starCtx.fillStyle = 'white'
                starCtx.beginPath();
                starCtx.arc(x, y, size, 0, 2 * Math.PI);
                starCtx.fill();
            }

            // star texture
            const starTexture = new THREE.CanvasTexture( starCanvas );
            starTexture.mapping = THREE.UVMapping;

            // star material
            starMaterial = new THREE.MeshStandardMaterial(
                { map: starTexture, side: THREE.BackSide, transparent: true, opacity: 0, emissive: 0xffffff, emissiveIntensity: 50 } );

            const starGeometry = new THREE.SphereGeometry( 100,  8, 8 );


            starMesh = new THREE.Mesh( starGeometry, starMaterial );
            scene.add( starMesh );

            starMesh.position.copy(controls.getObject().position);

            /// Set initial values

            const effectController = {
                turbidity: 10,
                rayleigh: 3,
                mieCoefficient: 0.005,
                mieDirectionalG: 0.975,
                elevation: 0,
                azimuth: 180,
                exposure: renderer.toneMappingExposure
            };

            function setSky() {

                const uniforms = sky.material.uniforms;
                uniforms[ 'turbidity' ].value = effectController.turbidity;
                uniforms[ 'rayleigh' ].value = effectController.rayleigh;
                uniforms[ 'mieCoefficient' ].value = effectController.mieCoefficient;
                uniforms[ 'mieDirectionalG' ].value = effectController.mieDirectionalG;

                const phi = THREE.MathUtils.degToRad( 90 - effectController.elevation );
                const theta = THREE.MathUtils.degToRad( effectController.azimuth );

                sun.setFromSphericalCoords( 1, phi, theta );

                // sunLight.position.copy(sun);

                uniforms[ 'sunPosition' ].value.copy( sun );


                // Calculate the zenith angle cosine
                const sunDirection = new THREE.Vector3().copy(sunLight.position).normalize();
                const zenithAngleCos = sunDirection.y; // Assuming the up direction is (0, 1, 0)

                // Calculate the sun intensity
                const intensity = sunIntensity(zenithAngleCos);

                // Set the light intensity
                sunLight.intensity = intensity
                // console.log(sunLight.intensity);

                composer.render()



            }

            setSky();
            
            sunUpdateInterval = setInterval(function() {
                
                if(controls.enabled) {

                
                    cubeCamera.update(renderer, scene)
                }
                
                
            }, 300);
            
                        
        }

        function calculateSunPosition(time) {
            
            const dayDuration = dayLength; // seconds in a day
            const dayTime = time % dayDuration;
            let dayPercentage = (dayTime / dayDuration) % 1
            
            const elevation = (dayPercentage * 360) % 360;

            // console.log(elevation, dayPercentage)
            

            const azimuth = 90


            return { elevation, azimuth, dayPercentage };
        }

        function updateSunPosition(time) {
            const { elevation, azimuth, dayPercentage } = calculateSunPosition(time);    

            const phi = THREE.MathUtils.degToRad( 90 - elevation );
            const theta = THREE.MathUtils.degToRad( azimuth );

            sun.setFromSphericalCoords( 20, phi, theta );
            sunLight.position.copy(sun);

            sky.material.uniforms[ 'sunPosition' ].value.copy( sun );

            starMesh.rotation.z = -phi /4;
            
            if (dayPercentage >= 0.5 && dayPercentage < 0.75) {
                starMaterial.opacity = (dayPercentage - 0.5) * 4;
            } else if (dayPercentage >= 0.75 && dayPercentage < 1) {
                starMaterial.opacity = (1 - dayPercentage) * 4;
            } else {
                starMaterial.opacity = 0;
            }
            // console.log(starMaterial.opacity, dayPercentage)

            // Calculate the zenith angle cosine
            const sunDirection = new THREE.Vector3().copy(sunLight.position).normalize();
            const zenithAngleCos = sunDirection.y; // Assuming the up direction is (0, 1, 0)

            // Calculate the sun intensity
            const intensity = sunIntensity(zenithAngleCos);

            // Set the light intensity
            sunLight.intensity = intensity

            // console.log(sunLight.intensity);
            // sunHelper.update();
        }

        function sunIntensity(zenithAngleCos) {
            const cutoffAngle = 1.6110731556870734;
            const steepness = 1.5;
            const EE = 10.0;

            zenithAngleCos = Math.max(-1, Math.min(1, zenithAngleCos));
            return EE * Math.max(0, 1 - Math.exp(-(cutoffAngle - Math.acos(zenithAngleCos)) / steepness));
        }






        async function controlsSetup() {
            // controls
          

            controls = new PointerLockControlsCannon(camera, playerBody)
            scene.add(controls.getObject())

            player.pitchObject = controls.getObject().children[0];
            player.pitchObject.position.set(0, 1, 0);

            
            //heavy body is mesh called heavy_arm
            // let playerScene = await loadGLTF('assets/heavy.glb', 1)
            // console.log(playerScene)
            // player.model = playerScene.scene.children[0];
            // player.model.frustumCulled = false;
            // player.model.traverse(child => {
            //     child.frustumCulled = false;
            // });

            // const mixer = new THREE.AnimationMixer(player.model);
            // player.mixer = mixer;
            // mixers.push(mixer);

            // player.actions = player.actions || {};
            // for (const animation of playerScene.animations) {
            //     const action = mixer.clipAction(animation);
            //     console.log(animation)
            //     if (animation.name !== 'idle') {
            //         action.setEffectiveWeight(0);
            //     }
            //     player.actions[animation.name] = action;
            // }
            
            // console.log(player)

            // player.actions['idle'].play();

            // player.idleClip = player.actions['idle'].getClip();
            // player.grabClip = player.actions['grab_add'].getClip();
            // player.walkClip = player.actions['walk'].getClip();
            // player.jumpClip = player.actions['jump'].getClip();
            // player.fallClip = player.actions['fall'].getClip();
            
            // THREE.AnimationUtils.makeClipAdditive(player.grabClip, 0, player.idleClip, 30);
            // THREE.AnimationUtils.makeClipAdditive(player.walkClip, 0, player.idleClip, 30);
            // THREE.AnimationUtils.makeClipAdditive(player.jumpClip, 0, player.idleClip, 30);
            // THREE.AnimationUtils.makeClipAdditive(player.fallClip, 0, player.idleClip, 30);
            
            // let additiveGrabAddAction = player.mixer.clipAction(player.grabClip);
            // let additiveWalkAction = player.mixer.clipAction(player.walkClip);
            // let additiveJumpAction = player.mixer.clipAction(player.jumpClip);
            // let additiveFallAction = player.mixer.clipAction(player.fallClip);
            

            // player.actions['grab_add'] = additiveGrabAddAction;
            // player.actions['walk'] = additiveWalkAction;
            // player.actions['jump'] = additiveJumpAction;
            // player.actions['fall'] = additiveFallAction;
        
            // player.actions['grab_add'].setEffectiveWeight(0);
            // player.actions['grab_add'].play();
            // player.actions['walk'].setEffectiveWeight(0);
            // player.actions['walk'].play();
            // player.actions['jump'].setEffectiveWeight(0);
            // player.actions['jump'].setLoop(THREE.LoopOnce);
            // player.actions['jump'].play();
            // player.actions['fall'].setEffectiveWeight(0);
            // player.actions['fall'].play();
            // player.actions['idle'].play();
            // player.actions['grab_add'].setEffectiveWeight(1);
            // player.actions['grab_add'].play()
            // console.log(player.actions['idle'].getClip())
            // player.actions['idle'].fadeOut(1);

            // player.actions['grab_add'].blendMode = THREE.AdditiveAnimationBlendMode
            // player.actions['grab_add'].fadeIn(0.1);
            // player.actions['grab_add'].crossFadeFrom(player.actions['idle'], 1, false).play()
            // console.log(player.actions['idle'])

            player.yawObject = controls.getObject();

            // player.yawObject.add(player.model);
            // player.model.scale.set(0.7, 0.7, 0.7 );
            // player.model.position.set(0, -0.2, -.1);

            yawBody = new CANNON.Body({
                mass: 0,
                shape: new CANNON.Box(new CANNON.Vec3(0.1, 0.1, 0.1)),
                collisionResponse: true,
            })
            yawBody.position.set(0, 0, 0);
            world.addBody(yawBody);

            ragdollSetup(true, 0.4, 0.01)


            window.addEventListener('click', () => {
                if (!isPaused) {
                    controls.enabled = true
                    controls.lock()
                }
            })

            controls.addEventListener('lock', () => {
                isPaused = false;
                controls.enabled = true
                
                if (pauseStartTime !== undefined) {
                    pausedTime += performance.now() - pauseStartTime;
                }
                crosshair.style.display = null;
                pauseMenu.style.display = 'none';

                // animate()
                // instructions.style.display = 'none'
            })

            controls.addEventListener('unlock', () => {
                controls.enabled = false
                isPaused = true;
                pauseStartTime = performance.now();
                pauseMenu.style.display = null;
                crosshair.style.display = 'none';
                // instructions.style.display = null
            })
        }

        function fadeOutAnimation(determiner, action, duration) {
            if (determiner && action && action.weight > 0) {
                // console.log('fading out')
                // action.fadeOut(duration || 0.1);
            }

        }

        function fadeInAnimation(determiner, action, duration) {
            if (determiner && action && action.weight < 1) {
                // console.log('fading in', action.weight)
                // action.fadeIn(duration || 0.1);
            }
        }

        function statsSetup() {
            // stats
            stats = new Stats();
            document.body.appendChild( stats.dom );
        }

        function physicsSetup() {
            // physics
            world = new CANNON.World({
                gravity: new CANNON.Vec3(0, -9.82, 0), // m/sÂ²
            })

            world.allowSleep = true

            cannonDebugger = new CannonDebugger(scene, world, {
                onInit(body, mesh) {
                    // Toggle visibiliy on "d" press
                    mesh.visible = false
                    document.addEventListener('keydown', (event) => {
                    if (event.key === '=') {
                        mesh.visible = !mesh.visible
                    }
                    })
                },
            })

            slipMaterial = new CANNON.Material('slippery')
            slipMaterial.friction = 0

            handBody = new CANNON.Body({
                mass: 0,
                shape: new CANNON.Sphere(0.1),
                collisionResponse: false,
            })
            handBody.position.set(0, 0, 0)
            world.addBody(handBody)


        }
        
        function createObjects() {
            // objects
            defaultMaterial = new THREE.MeshNormalMaterial();
            defaultGeometry = new THREE.BoxGeometry( 0.2, 0.2, 0.2 );
            defaultRadius = 1;

            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry( 100, 100, 100, 100 ),
                new THREE.MeshStandardMaterial( { color: 0x808080, side: THREE.DoubleSide } )
            );

            floor.receiveShadow = true;

            floor.rotation.x = - Math.PI / 2;
            floor.position.y = -1;
            scene.add( floor );

            const groundBody = new CANNON.Body({
                type: CANNON.Body.STATIC, // can also be achieved by setting the mass to 0
                shape: new CANNON.Plane(),
                collisionFilterGroup: EVERYTHING_ELSE_GROUP,
                collisionFilterMask: PLAYER_GROUP | EVERYTHING_ELSE_GROUP,
            })

            groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0) // make it face up
            groundBody.position.set(0, -1, 0) // m

            groundBody.name = 'floor'
            world.addBody(groundBody)

            const sphereBody = new CANNON.Body({
                mass: 5, // kg
                shape: new CANNON.Sphere(defaultRadius),
                collisionFilterGroup: EVERYTHING_ELSE_GROUP,
                collisionFilterMask: PLAYER_GROUP | EVERYTHING_ELSE_GROUP,
            })
            sphereBody.position.set(0, 10, 0) // m
            world.addBody(sphereBody)

            sphereBody.damping = 0.9
            sphereBody.angularDamping = 0.99
            sphereBody.name = 'sphere'

            const geometry = new THREE.SphereGeometry(defaultRadius)
            const sphereMesh = new THREE.Mesh(geometry, defaultMaterial)
            scene.add(sphereMesh)

            meshMap.set(sphereBody, sphereMesh)

            const boxBody = new CANNON.Body({
                mass: 5, // kg
                shape: new CANNON.Box(new CANNON.Vec3(0.1, 0.1, 0.1)), // m
                collisionFilterGroup: EVERYTHING_ELSE_GROUP,
                collisionFilterMask: PLAYER_GROUP | EVERYTHING_ELSE_GROUP,
            })
            boxBody.position.set(0, 5, 0) // m
            world.addBody(boxBody)
            boxBody.name = 'box'
            
            const box = new THREE.Mesh( defaultGeometry, defaultMaterial );
            scene.add( box );

            meshMap.set(boxBody, box)
            
        }


        function inputSetup() {
            let keyDownListener = function(event) {
                event.preventDefault();
                // console.log(event.code);
                keys[event.code] = true;
                // console.log(keys);
            };

            let keyUpListener = function(event) {
                event.preventDefault();
                // console.log(event.code);
                keys[event.code] = false;
            };

            window.addEventListener('keydown', keyDownListener);
            window.addEventListener('keyup', keyUpListener);

            window.addEventListener('wheel', function(event) {
                if (event.deltaY < 0) {
                    scrollDirection = -1;
                } else if (event.deltaY > 0) {
                    scrollDirection = 1;
                }
            });

            resumeBtn.addEventListener('click', resume);
            settingsBtn.addEventListener('click', () => {
                pauseDefault.style.display = 'none';
                settingsMenu.style.display = null;
                controlsList.style.display = 'none';
            });

            controlsBtn.addEventListener('click', () => {
                pauseDefault.style.display = 'none';
                settingsMenu.style.display = 'none';
                controlsList.style.display = null;
            });

            restartBtn.addEventListener('click', () => {
                location.reload();
            });

            backBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    settingsMenu.style.display = 'none';
                    pauseDefault.style.display = null;
                    controlsList.style.display = 'none';
                });
            });
        }

        function createPlayer() {
            playerMaterial = slipMaterial;

            playerShape = new CANNON.Sphere(0.1)

            playerBody = new CANNON.Body({ mass: 5 })
            playerBody.addShape(playerShape, new CANNON.Vec3(0, 0, 0))
            playerBody.isPlayer = true
            playerBody.collisionFiltergroup = PLAYER_GROUP
            playerBody.collisionFilterMask = EVERYTHING_ELSE_GROUP
            player.playerBody = playerBody
            // playerBody.fixedRotation = true
            // playerBody.updateMassProperties()
            

            
            // playerBody.position.set(-8, 5, 0)
            
            playerBody.linearDamping = 0.99
            playerBody.angularDamping = 0.99
            playerBody.allowSleep = false

            player.crouching = false;
            
            world.addBody(playerBody)

            player.anim.grabDest.body = new CANNON.Body({ mass: 0, collisionResponse: false})
            player.anim.grabDest.body.addShape(new CANNON.Box(new CANNON.Vec3(0.1, 0.1, 0.1)))
            player.anim.grabDest.body.position.set(0, 0, 0)
            world.addBody(player.anim.grabDest.body)
        }

        // animation

        player.isJumping = false;
        let accumulatedTime = 0;

        function animate() {
            
            // console.log(dt)

            if (controls.enabled) {
                if(isPaused) return;
           
                const time = (performance.now() - pausedTime) / 1000
                const dt = time - lastCallTime
                lastCallTime = time

                accumulatedTime += dt;

                timeStep = (1 / (1/dt)) < 1/30 ? 1 / (1/dt) : 1/30;

                if(accumulatedTime >= timeStep) {

                    for (const [body, mesh] of meshMap) {
                        mesh.position.copy(body.position)
                        mesh.quaternion.copy(body.quaternion)
                        mesh.castShadow = true
                        mesh.receiveShadow = true
                    }
                    
                    mixers.forEach(mixer => mixer.update(dt))

                    updateSunPosition(lastCallTime);

                    // if(player.currentAction.time >= 1) {
                    //     player.currentAction.stop();
                    //     player.currentAction = null;
                    // }

                    // updateSunPosition(time)

                    // cubeCamera.update(renderer, scene)

                    // spotLightHelper.update()

                    // sunHelper.update()

                    if(keys['KeyF']) {
                        spotLight.intensity = spotLight.intensity === 0 ? 3 : 0;
                        keys['KeyF'] = false;
                    }
                    if(keys['KeyE']) {
                        grabObjectCheck(grabBody);
                        keys['KeyE'] = false;
                    }

                    if(keys['KeyC']) {
                        player.crouching = !player.crouching;
                        keys['KeyC'] = false;
                    }

                    player.pitchObject.position.y = player.crouching ? Math.max(player.pitchObject.position.y - 0.01, 0.5) : Math.min(player.pitchObject.position.y + 0.01, 1);

                    if(controls.canJump === false && playerBody.velocity.y <= 0 && playerBody.velocity.y >= -50) {
                        playerBody.velocity.y -= 0.1 * (-playerBody.velocity.y / 3)
                    }
                

                    outlineRaycast();
                    
                    moveGrabbedObject()

                    
                
                    player.anim.grabDest.body.position.copy(player.anim.grabDest.getWorldPosition(new THREE.Vector3()))
                    player.anim.grabDest.body.velocity.copy(playerBody.velocity)

                    yawBody.position.copy(player.pitchObject.getWorldPosition(new THREE.Vector3()));
                    yawBody.velocity.copy(playerBody.velocity);

                    const playerPitchRotation = player.yawObject.rotation;

                    yawBody.quaternion.setFromEuler(0, playerPitchRotation.y, 0, 'XYZ');

                    const forwardQuaternion = new CANNON.Quaternion();
                    forwardQuaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), Math.PI);
                    yawBody.quaternion = yawBody.quaternion.mult(forwardQuaternion);

                    const horizontalQuaternion = new CANNON.Quaternion();
                    horizontalQuaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
                    yawBody.quaternion = yawBody.quaternion.mult(horizontalQuaternion);

                    //we want to move the player.hand in and out with the scroll wheel
                    if(scrollDirection !== 0) {
                        player.hand.position.z > -50 ? player.hand.position.z += scrollDirection : player.hand.position.z = -50;
                        console.log(player.hand.position.z)
                        // if(player.hand.position.z > 0) player.hand.position.z = -1;
                        if(player.hand.position.z >= -1) player.hand.position.z = -1;
                        scrollDirection = 0;
                        
                    }

                    handBody.position.copy(player.hand.getWorldPosition(new THREE.Vector3()));
                    handBody.velocity.copy(playerBody.velocity);

                

                    starMesh.position.copy(controls.getObject().position);

                    

                    controls.update(dt)
                    controls.quaternion.normalize()
                    // renderer.render(scene, camera)

                    accumulatedTime = 0;

                }

                world.step(timeStep, dt)
                cannonDebugger.update()

                currentRenderer === renderer ? renderer.render(scene, camera) : composer.render()
                
                stats.update()

                
                // console.log(1/dt)
            }
        }

        function getCameraFacing() {
            const euler = new THREE.Euler(controls.pitchObject.rotation.x, controls.yawObject.rotation.y, 0, 'YXZ');
            const quaternion = new THREE.Quaternion().setFromEuler(euler);
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(quaternion);
            return direction;
        }

        function playerRaycast() {
            // Create a direction vector
            const direction = getCameraFacing();

            // Get the camera's world position
            const cameraPosition = new THREE.Vector3();
            controls.getObject().children[0].children[0].getWorldPosition(cameraPosition);
            
            // Create a ray starting from the player position
            const cannonDirection = new CANNON.Vec3(direction.x, direction.y, direction.z);
            const from = new CANNON.Vec3(cameraPosition.x, cameraPosition.y, cameraPosition.z - 0.1);
            const to = from.vadd(cannonDirection.scale(10));
        
            // Draw a line from the player's position in the direction they're facing
            // const lineGeometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(from.x, from.y, from.z), new THREE.Vector3(to.x, to.y, to.z)]);
            // const lineMaterial = new THREE.LineBasicMaterial({color: 0xff0000});
            // const line = new THREE.Line(lineGeometry, lineMaterial);
            // scene.add(line);
        
            // Remove the line after a certain amount of time
            // setTimeout(() => scene.remove(line), 500);
        
            const result = new CANNON.RaycastResult();
            world.raycastClosest(from, to, {collisionFilterMask: EVERYTHING_ELSE_GROUP, skipBackfaces: true}, result);
        
            return result;
        }

        let castBody = null;

        function outlineRaycast() {
            // if(grabbedObject) {setCrosshair('grab'); return;}
            let cast = playerRaycast()
            // if(castBody === cast.body) return;

           
            castBody = cast.body;

            if(castBody && castBody.mass === 0) {
                outlinePass.selectedObjects = [];
                grabBody = null;
                grabbedObject === null ? setCrosshair('look') : setCrosshair('grab');
                return;
            }
            let castMesh = meshMap.get(castBody);

            if(castMesh) {
                outlinePass.selectedObjects = [castMesh];
                grabBody = castBody;
                grabBody.cast = cast;
                setCrosshair('grab');
            } else {
                outlinePass.selectedObjects = [];
                grabBody = null;
                grabbedObject === null ? setCrosshair('look') : setCrosshair('grab');
            }
        }

        function grabObjectCheck(body) {
            if(body === null) {grabbedObject = null; isGrabbing = false; removegrabConstraint(); world.removeConstraint(player.handConstraint); return;}
            if(body.mass === 0) return;
            
            if(grabbedObject) {
                //release object
                if(grabbedObject === body) {
                    grabbedObject = null;
                    isGrabbing = false;
                    removegrabConstraint();
                    world.removeConstraint(player.handConstraint);
                } else {
                    //grab object
                    grabbedObject = body;
                    isGrabbing = true;
                    // player.hand.position.z = -grabBody.cast.distance;
                    // console.log(grabBody.cast.distance, player.hand)
                    removegrabConstraint();

                    addJointConstraint(grabBody.cast.hitPointWorld, grabbedObject);
                    moveJoint(grabBody.cast.distance);

                    world.addConstraint(player.handConstraint);
                }
            } else {
                //grab object
                grabbedObject = body;
                isGrabbing = true;
                // player.hand.position.z = -grabBody.cast.distance;
                // console.log(grabBody.cast, player.hand)
                removegrabConstraint();
                
                addJointConstraint(grabBody.cast.hitPointWorld, grabbedObject);
                moveJoint(grabBody.cast.distance);

                world.addConstraint(player.handConstraint);

            }
            console.log(grabbedObject, isGrabbing);
        }

        function createDebugSphere(position, timeout = 5000) {
            const sphereGeometry = new THREE.SphereGeometry(0.2, 32, 32);
            const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphereMesh.position.copy(position);
            scene.add(sphereMesh);

            setTimeout(() => {
                scene.remove(sphereMesh);
            }, timeout);
        }

        let constrained = [];

        function addJointConstraint(position, constrainedBody) {
            constrainedBody.originalDampingA = constrainedBody.angularDamping;
            constrainedBody.originalDampingL = constrainedBody.linearDamping;
            constrainedBody.linearDamping = 0.999;
            constrainedBody.angularDamping = 0.999;

            constrained.push(constrainedBody);

            // Vector that goes from the body to the clicked point
            const vector = new CANNON.Vec3().copy(position).vsub(constrainedBody.position)

            // Apply anti-quaternion to vector to tranform it into the local body coordinate system
            const antiRotation = constrainedBody.quaternion.inverse()
            const pivot = antiRotation.vmult(vector) // pivot is not in local body coordinates

            // Move the cannon click marker body to the click position
            handBody.position.copy(position)

            // Create a new constraint
            // The pivot for the jointBody is zero
            grabConstraint = new CANNON.PointToPointConstraint(constrainedBody, pivot, handBody, new CANNON.Vec3(0, 0, 0))

            // Add the constraint to world
            world.addConstraint(grabConstraint)
        }

        // This functions moves the joint body to a new postion in space
        // and updates the constraint
        function moveJoint(position) {
            player.hand.position.z = -position
            grabConstraint.update()
        }

        // Remove constraint from world
        function removegrabConstraint() {
            world.removeConstraint(grabConstraint)
            grabConstraint = undefined
            constrained.forEach(body => {
                body.angularDamping = body.originalDampingA;
                body.linearDamping = body.originalDampingL;
                constrained = constrained.filter(b => b !== body);
            });
        }


        function moveGrabbedObject() {
            if(grabbedObject) {
                // let destination = player.hand.getWorldPosition(new THREE.Vector3());
                // //add grabDest to destination relative to camerafacing
                // destination.add(getCameraFacing().multiplyScalar(-player.grabDest.z));

                
                // // console.log(destination)
                // //subtract the difference between the object position and the destination
                // let difference = new CANNON.Vec3(destination.x - grabbedObject.position.x, destination.y - grabbedObject.position.y, destination.z - grabbedObject.position.z);
                // grabbedObject.wakeUp();
                // grabbedObject.angularVelocity.set(0, 0, 0);
                // grabbedObject.velocity.set(0, 0, 0);
                // // grabbedObject.position.set(destination.x, destination.y, destination.z);
                // grabbedObject.velocity.set(difference.x, difference.y, difference.z);
                // // console.log(difference)
                // player.handConstraint.update();
               
                
                //only apply force in sync with timestep
                // console.log(dt, timeStep)

                // accumulatedTime += dt;

                // if(accumulatedTime >= timeStep) {
                //     player.handConstraint.applyForce();
                //     accumulatedTime = 0;
                // }

                
            }
        }

        async function loadGLTF(url, scale) {
            const loader = new GLTFLoader();
            return new Promise((resolve, reject) => {

                loader.load(url, function (gltf) {
                    // gltf.scene.scale.set(0.9, 0.9, 0.9);
                    

                    gltf.scene.traverse( function ( child ) {
                        if ( child.isMesh ) {
                            if (child.material.isMeshStandardMaterial) {
                                // console.log(child.material);
                                // child.material.metalness = 0;
                                // child.material.roughness = 0.5;
                                // child.material.envMapIntensity = globalEnvMapIntensity;
                                // matList.push(child.material);
                            } else if (Array.isArray(child.material)) {
                                child.material.forEach(mat => {
                                    if (mat.isMeshStandardMaterial) {
                                        // mat.metalness = 0;
                                        // mat.roughness = 0.5;
                                        // mat.envMapIntensity = globalEnvMapIntensity;
                                        // matList.push(mat);
                                    }
                                });
                            }
                            child.castShadow = true;
                            child.receiveShadow = true;                       

                            let shapeType;
                            switch (child.userData.shapeType) {
                                case 'SPHERE':
                                    shapeType = ShapeType.SPHERE;
                                    sphereCollision(child, child.userData.radius || 0.5);
                                    break;
                                case 'BOX':
                                    shapeType = ShapeType.BOX;
                                    boxCollision(child, child.userData.size);
                                    break;
                                case 'CYLINDER':
                                    shapeType = ShapeType.CYLINDER;
                                    cylinderCollision(child, child.userData.radiusTop, child.userData.radiusBottom, child.userData.height, child.userData.resolution);
                                    break;
                                case 'HULL':
                                    shapeType = ShapeType.HULL;
                                    hullCollision(child);
                                    break;
                                case 'MESH':
                                    shapeType = ShapeType.MESH;
                                    meshCollision(child);
                                    break;
                                default:
                                    //no collision
                                break;
                            }
                        }
                    });

                    resolve(gltf);
                }, undefined, function (error) {
                    // Reject the promise if there's an error
                    reject(error);
                });
            });

        }

        function sphereCollision(child, radius) {
            let sphereBody = new CANNON.Body({
                mass: child.userData.mass || 0, 
                collisionFilterGroup: EVERYTHING_ELSE_GROUP,
                collisionFilterMask: PLAYER_GROUP | EVERYTHING_ELSE_GROUP,});
            let sphere = new CANNON.Sphere(radius);
            sphereBody.addShape(sphere);
            sphereBody.position.set(child.position.x, child.position.y, child.position.z);
            world.addBody(sphereBody);
            meshMap.set(sphereBody, child);
        }

        function boxCollision(child, size) {
            let boxBody = new CANNON.Body({
                mass: child.userData.mass || 0,
                collisionFilterGroup: EVERYTHING_ELSE_GROUP,
                collisionFilterMask: PLAYER_GROUP | EVERYTHING_ELSE_GROUP,
            });
            let dimensions;
            if(size !== undefined) {
                dimensions = new CANNON.Vec3(size.x, size.y, size.z);
            } else {
                //get dimensions from mesh
                let box = new THREE.Box3().setFromObject(child);
                dimensions = new CANNON.Vec3((box.max.x - box.min.x)/2, (box.max.y - box.min.y)/2, (box.max.z - box.min.z)/2);
            }
            let box = new CANNON.Box(dimensions);
            boxBody.addShape(box);
            boxBody.position.set(child.position.x, child.position.y, child.position.z);
            world.addBody(boxBody);
            meshMap.set(boxBody, child);
        }

        function cylinderCollision(child, radiusTop, radiusBottom, height, resolution) {
            let cylinderBody = new CANNON.Body({
                mass: child.userData.mass || 0,
                collisionFilterGroup: EVERYTHING_ELSE_GROUP,
                collisionFilterMask: PLAYER_GROUP | EVERYTHING_ELSE_GROUP,
            });
            radiusTop = radiusTop ? radiusTop : radiusBottom ? radiusBottom : 0.5;
            radiusBottom = radiusBottom ? radiusBottom : radiusTop ? radiusTop : 0.5;
            let cylinder = new CANNON.Cylinder(radiusTop, radiusBottom, height, resolution);
            cylinderBody.addShape(cylinder);
            cylinderBody.position.set(child.position.x, child.position.y, child.position.z);
            world.addBody(cylinderBody);
            meshMap.set(cylinderBody, child);
        }

        function hullCollision(child) {
            let hullType = child.userData.hullType || 'mesh';
            let hullBody = new CANNON.Body({
                mass: child.userData.mass || 0,
                collisionFilterGroup: EVERYTHING_ELSE_GROUP,
                collisionFilterMask: PLAYER_GROUP | EVERYTHING_ELSE_GROUP,
            });
            let shape;
            switch(hullType) {
                case 'mesh':
                    //create hull from mesh
                    shape = threeToCannon(child, {type: ShapeType.HULL});
                    
                    
                    hullBody.addShape(shape.shape);
                break;
                case 'colobject':
                    //create hull from child with name ending in .col
                    let colMesh = child.children.filter(child => child.name.endsWith('col'))[0];
                    console.log(colMesh);
                    shape = threeToCannon(colMesh, {type: ShapeType.HULL});
                    hullBody.addShape(shape.shape, shape.offset, shape.orientation);
                    child.remove(colMesh);
                break;
                case 'vhacd':
                    //child has many children, each a convex hull
                    //they will have _hull_ in their name
                    let hulls = child.children.filter(child => child.name.includes('_hull_'));
                    hulls.forEach(hull => {
                        // hull position is (5.82892, -0.193318, -0.683173);
                        //offset should be the difference between the child and the hull object
                        let offset = new CANNON.Vec3(
                            hull.position.x + child.position.x,
                            hull.position.y + child.position.y,
                            hull.position.z + child.position.z
                        );
                        offset = offset.vsub(child.position);
                        let hullShape = threeToCannon(hull, {type: ShapeType.HULL});
                        hullBody.addShape(hullShape.shape, offset);
                        child.remove(hull);
                    });
                    
                break;
            }
            hullBody.position.set(child.position.x, child.position.y, child.position.z);
            hullBody.quaternion.set(child.quaternion.x, child.quaternion.y, child.quaternion.z, child.quaternion.w);
            world.addBody(hullBody);
            meshMap.set(hullBody, child);
        }

        const wheels = [];
        
        async function carSetup() {
            //car setup

            //materials

            const bodyMaterial = new THREE.MeshPhysicalMaterial( {
                color: 0xff0000, metalness: 1.0, roughness: 0.5, clearcoat: 1.0, clearcoatRoughness: 0.03
            } );

            const detailsMaterial = new THREE.MeshStandardMaterial( {
                color: 0xffffff, metalness: 1.0, roughness: 0.5
            } );

            const glassMaterial = new THREE.MeshPhysicalMaterial( {
                color: 0xffffff, metalness: 0.25, roughness: 0, transmission: 1.0
            } );

            const emissiveMaterial = new THREE.MeshStandardMaterial( {
                color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 10.0, metalness: 1.0, roughness: 0.5
            } );

            let ferrari = await loadGLTF('assets/ferrari2.glb', 1)
            scene.add(ferrari.scene);
            

            const carModel = ferrari.scene

            carModel.getObjectByName( 'body' ).material = bodyMaterial;

            carModel.getObjectByName( 'rim_fl' ).material = detailsMaterial;
            carModel.getObjectByName( 'rim_fr' ).material = detailsMaterial;
            carModel.getObjectByName( 'rim_rr' ).material = detailsMaterial;
            carModel.getObjectByName( 'rim_rl' ).material = detailsMaterial;
            carModel.getObjectByName( 'trim' ).material = detailsMaterial;

            carModel.getObjectByName( 'glass' ).material = glassMaterial;

            wheels.push(
                carModel.getObjectByName( 'wheel_fl' ),
                carModel.getObjectByName( 'wheel_fr' ),
                carModel.getObjectByName( 'wheel_rl' ),
                carModel.getObjectByName( 'wheel_rr' )
            );
        }


        function ragdollSetup(isPlayer = false, scale = 1, mass = 1) {
            const { bodies, constraints } = createRagdoll({
                scale: scale,
                angle: Math.PI / 2,
                angleShoulders: Math.PI / 3,
                twistAngle: Math.PI / 2,
                mass: mass,
            })

            bodies.forEach((body) => {
                // Move the ragdoll up
                body.allowSleep = false
                body.linearDamping = 0.99
                body.angularDamping = 0.99
                if(isPlayer) {
                    body.collisionFiltergroup = PLAYER_GROUP
                    body.collisionFilterMask = EVERYTHING_ELSE_GROUP
                }
                world.addBody(body)
            })

            constraints.forEach((constraint) => {
                world.addConstraint(constraint)
            })

            console.log(bodies)
            let ragdollChestBody = bodies.find(body => body.name === 'upperBody')
            //rotate to face opposite y
            // ragdollChestBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), Math.PI)


            console.log(ragdollChestBody)
            let localPivotPlayer = new CANNON.Vec3(0, 0, -0.3)
            let localPivotRagdoll = new CANNON.Vec3(0, 0, 0)
            let constraint = new CANNON.ConeTwistConstraint(yawBody, ragdollChestBody, {
                pivotA: localPivotPlayer,
                pivotB: localPivotRagdoll,
                axisA: new CANNON.Vec3(0, 1, 0),
                axisB:  new CANNON.Vec3(0, 1, 0),
                angle: 0,
                twistAngle: 0,
                
            })
            world.addConstraint(constraint)

            // we make a spring from handBody to the ragdoll's hand that we can activate when we want to grab something
            let ragdollHand = bodies.find(body => body.name === 'hand')
            player.ragdollHand = ragdollHand

            
            if(isPlayer) {
                const handConstraint = new CANNON.DistanceConstraint(player.ragdollHand, player.anim.grabDest.body, 0.7, 0.1)
                player.handConstraint = handConstraint;
            }
            

        }

        function createRagdoll({ scale = 1, angle, angleShoulders, twistAngle, mass = 1}) {
            const bodies = []
            const constraints = []

            let ragdollMeshMaterial = function() {
                let randomColour = Math.floor(Math.random()*(0xffffff - 0xaaaaaa) + 0xaaaaaa).toString(16);
                return new THREE.MeshStandardMaterial({
                    color: `#${randomColour}`,
                    metalness: 0.1,
                    roughness: 0.5,
                });
            }

            const shouldersDistance = 0.5 * scale
            const upperArmLength = 0.4 * scale
            const lowerArmLength = 0.4 * scale
            const upperArmSize = 0.2 * scale
            const lowerArmSize = 0.2 * scale
            const neckLength = 0.1 * scale
            const headRadius = 0.25 * scale
            const upperBodyLength = 0.6 * scale
            const pelvisLength = 0.4 * scale
            const upperLegLength = 0.5 * scale
            const upperLegSize = 0.2 * scale
            const lowerLegSize = 0.2 * scale
            const lowerLegLength = 0.5 * scale

            const headShape = new CANNON.Sphere(headRadius)
            const upperArmShape = new CANNON.Box(
            new CANNON.Vec3(upperArmLength * 0.5, upperArmSize * 0.5, upperArmSize * 0.5)
            )
            const lowerArmShape = new CANNON.Box(
            new CANNON.Vec3(lowerArmLength * 0.5, lowerArmSize * 0.5, lowerArmSize * 0.5)
            )
            const upperBodyShape = new CANNON.Box(
            new CANNON.Vec3(shouldersDistance * 0.5, lowerArmSize * 0.5, upperBodyLength * 0.5)
            )
            const pelvisShape = new CANNON.Box(
            new CANNON.Vec3(shouldersDistance * 0.5, lowerArmSize * 0.5, pelvisLength * 0.5)
            )
            const upperLegShape = new CANNON.Box(
            new CANNON.Vec3(upperLegSize * 0.5, lowerArmSize * 0.5, upperLegLength * 0.5)
            )
            const lowerLegShape = new CANNON.Box(
            new CANNON.Vec3(lowerLegSize * 0.5, lowerArmSize * 0.5, lowerLegLength * 0.5)
            )

            // Lower legs
            const lowerLeftLeg = new CANNON.Body({
            mass: mass,
            position: new CANNON.Vec3(shouldersDistance / 2, 0, lowerLegLength / 2),
            })
            const lowerRightLeg = new CANNON.Body({
            mass: mass,
            position: new CANNON.Vec3(-shouldersDistance / 2, 0, lowerLegLength / 2),
            })
            lowerLeftLeg.addShape(lowerLegShape)
            lowerRightLeg.addShape(lowerLegShape)
            bodies.push(lowerLeftLeg)
            bodies.push(lowerRightLeg)

            let lowerLeftLegMesh = new THREE.Mesh(new THREE.BoxGeometry(lowerLegSize, lowerLegSize, lowerLegLength), ragdollMeshMaterial());
            let lowerRightLegMesh = new THREE.Mesh(new THREE.BoxGeometry(lowerLegSize, lowerLegSize, lowerLegLength), ragdollMeshMaterial());
            scene.add(lowerLeftLegMesh);
            scene.add(lowerRightLegMesh);
            meshMap.set(lowerLeftLeg, lowerLeftLegMesh);
            meshMap.set(lowerRightLeg, lowerRightLegMesh);

            // Upper legs
            const upperLeftLeg = new CANNON.Body({
            mass: mass,
            position: new CANNON.Vec3(
                shouldersDistance / 2,
                0,
                lowerLeftLeg.position.z + lowerLegLength / 2 + upperLegLength / 2
            ),
            })
            const upperRightLeg = new CANNON.Body({
            mass: mass,
            position: new CANNON.Vec3(
                -shouldersDistance / 2,
                0,
                lowerRightLeg.position.z + lowerLegLength / 2 + upperLegLength / 2
            ),
            })
            upperLeftLeg.addShape(upperLegShape)
            upperRightLeg.addShape(upperLegShape)
            bodies.push(upperLeftLeg)
            bodies.push(upperRightLeg)
            let upperLeftLegMesh = new THREE.Mesh(new THREE.BoxGeometry(upperLegSize, lowerLegSize, upperLegLength), ragdollMeshMaterial());
            let upperRightLegMesh = new THREE.Mesh(new THREE.BoxGeometry(upperLegSize, lowerLegSize, upperLegLength), ragdollMeshMaterial());
            scene.add(upperLeftLegMesh);
            scene.add(upperRightLegMesh);
            meshMap.set(upperLeftLeg, upperLeftLegMesh);
            meshMap.set(upperRightLeg, upperRightLegMesh);

            // Pelvis
            const pelvis = new CANNON.Body({
            mass: mass,
            position: new CANNON.Vec3(0, 0, upperLeftLeg.position.z + upperLegLength / 2 + pelvisLength / 2),
            })
            pelvis.addShape(pelvisShape)
            bodies.push(pelvis)
            let pelvisMesh = new THREE.Mesh(new THREE.BoxGeometry(shouldersDistance, lowerArmSize, pelvisLength), ragdollMeshMaterial());
            scene.add(pelvisMesh);
            meshMap.set(pelvis, pelvisMesh);


            // Upper body
            const upperBody = new CANNON.Body({
            mass: mass,
            position: new CANNON.Vec3(0, 0, pelvis.position.z + pelvisLength / 2 + upperBodyLength / 2),
            })
            upperBody.addShape(upperBodyShape)
            upperBody.name = 'upperBody';
            bodies.push(upperBody)
            //make it vertical
            // upperBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.PI / 2)

            // let upperBodyMesh = new THREE.Mesh(new THREE.BoxGeometry(shouldersDistance, lowerArmSize, upperBodyLength), ragdollMeshMaterial());
            // scene.add(upperBodyMesh);
            // meshMap.set(upperBody, upperBodyMesh);

            // Head
            const head = new CANNON.Body({
            mass: mass,
            position: new CANNON.Vec3(0, 0, upperBody.position.z + upperBodyLength / 2 + headRadius + neckLength),
            })
            head.addShape(headShape)
            head.name = 'head';
            bodies.push(head)
            // let headMesh = new THREE.Mesh(new THREE.SphereGeometry(headRadius), ragdollMeshMaterial());
            // scene.add(headMesh);
            // meshMap.set(head, headMesh);

            // Upper arms
            const upperLeftArm = new CANNON.Body({
            mass: mass,
            position: new CANNON.Vec3(
                shouldersDistance / 2 + upperArmLength / 2,
                0,
                upperBody.position.z + upperBodyLength / 2
            ),
            })
            const upperRightArm = new CANNON.Body({
            mass: mass,
            position: new CANNON.Vec3(
                -shouldersDistance / 2 - upperArmLength / 2,
                0,
                upperBody.position.z + upperBodyLength / 2
            ),
            })
            upperLeftArm.addShape(upperArmShape)
            upperRightArm.addShape(upperArmShape)
            bodies.push(upperLeftArm)
            bodies.push(upperRightArm)
            let upperLeftArmMesh = new THREE.Mesh(new THREE.BoxGeometry(upperArmLength, upperArmSize, upperArmSize), ragdollMeshMaterial());
            let upperRightArmMesh = new THREE.Mesh(new THREE.BoxGeometry(upperArmLength, upperArmSize, upperArmSize), ragdollMeshMaterial());
            scene.add(upperLeftArmMesh);
            scene.add(upperRightArmMesh);
            meshMap.set(upperLeftArm, upperLeftArmMesh);
            meshMap.set(upperRightArm, upperRightArmMesh);

            // Lower arms
            const lowerLeftArm = new CANNON.Body({
            mass: mass,
            position: new CANNON.Vec3(
                upperLeftArm.position.x + lowerArmLength / 2 + upperArmLength / 2,
                0,
                upperLeftArm.position.z
            ),
            })
            const lowerRightArm = new CANNON.Body({
            mass: mass,
            position: new CANNON.Vec3(
                upperRightArm.position.x - lowerArmLength / 2 - upperArmLength / 2,
                0,
                upperRightArm.position.z
            ),
            })
            lowerLeftArm.addShape(lowerArmShape)
            lowerRightArm.addShape(lowerArmShape)
            bodies.push(lowerLeftArm)
            bodies.push(lowerRightArm)
            lowerRightArm.name = 'hand';
            let lowerLeftArmMesh = new THREE.Mesh(new THREE.BoxGeometry(lowerArmLength, lowerArmSize, lowerArmSize), ragdollMeshMaterial());
            let lowerRightArmMesh = new THREE.Mesh(new THREE.BoxGeometry(lowerArmLength, lowerArmSize, lowerArmSize), ragdollMeshMaterial());
            scene.add(lowerLeftArmMesh);
            scene.add(lowerRightArmMesh);
            meshMap.set(lowerLeftArm, lowerLeftArmMesh);
            meshMap.set(lowerRightArm, lowerRightArmMesh);

            // Neck joint
            const neckJoint = new CANNON.ConeTwistConstraint(head, upperBody, {
            pivotA: new CANNON.Vec3(0, 0, -headRadius - neckLength / 2),
            pivotB: new CANNON.Vec3(0, 0, upperBodyLength / 2),
            axisA: CANNON.Vec3.UNIT_Z,
            axisB: CANNON.Vec3.UNIT_Z,
            angle: 0,
            twistAngle: 0,
            })
            constraints.push(neckJoint)

            // Knee joints
            const leftKneeJoint = new CANNON.ConeTwistConstraint(lowerLeftLeg, upperLeftLeg, {
            pivotA: new CANNON.Vec3(0, 0, lowerLegLength / 2),
            pivotB: new CANNON.Vec3(0, 0, -upperLegLength / 2),
            axisA: CANNON.Vec3.UNIT_Z,
            axisB: CANNON.Vec3.UNIT_Z,
            angle,
            twistAngle,
            })
            const rightKneeJoint = new CANNON.ConeTwistConstraint(lowerRightLeg, upperRightLeg, {
            pivotA: new CANNON.Vec3(0, 0, lowerLegLength / 2),
            pivotB: new CANNON.Vec3(0, 0, -upperLegLength / 2),
            axisA: CANNON.Vec3.UNIT_Z,
            axisB: CANNON.Vec3.UNIT_Z,
            angle,
            twistAngle,
            })
            constraints.push(leftKneeJoint)
            constraints.push(rightKneeJoint)

            // Hip joints
            const leftHipJoint = new CANNON.ConeTwistConstraint(upperLeftLeg, pelvis, {
            pivotA: new CANNON.Vec3(0, 0, upperLegLength / 2),
            pivotB: new CANNON.Vec3(shouldersDistance / 2, 0, -pelvisLength / 2),
            axisA: CANNON.Vec3.UNIT_Z,
            axisB: CANNON.Vec3.UNIT_Z,
            angle,
            twistAngle,
            })
            const rightHipJoint = new CANNON.ConeTwistConstraint(upperRightLeg, pelvis, {
            pivotA: new CANNON.Vec3(0, 0, upperLegLength / 2),
            pivotB: new CANNON.Vec3(-shouldersDistance / 2, 0, -pelvisLength / 2),
            axisA: CANNON.Vec3.UNIT_Z,
            axisB: CANNON.Vec3.UNIT_Z,
            angle,
            twistAngle,
            })
            constraints.push(leftHipJoint)
            constraints.push(rightHipJoint)

            // Spine
            const spineJoint = new CANNON.ConeTwistConstraint(pelvis, upperBody, {
            pivotA: new CANNON.Vec3(0, 0, pelvisLength / 2),
            pivotB: new CANNON.Vec3(0, 0, -upperBodyLength / 2),
            axisA: CANNON.Vec3.UNIT_Z,
            axisB: CANNON.Vec3.UNIT_Z,
            angle: angle / 4,
            twistAngle: twistAngle / 8,
            })
            constraints.push(spineJoint)

            // Shoulders
            const leftShoulder = new CANNON.ConeTwistConstraint(upperBody, upperLeftArm, {
            pivotA: new CANNON.Vec3(shouldersDistance / 2, 0, upperBodyLength / 2),
            pivotB: new CANNON.Vec3(-upperArmLength / 2, 0, 0),
            axisA: CANNON.Vec3.UNIT_X,
            axisB: CANNON.Vec3.UNIT_X,
            angle: angleShoulders,
            })
            const rightShoulder = new CANNON.ConeTwistConstraint(upperBody, upperRightArm, {
            pivotA: new CANNON.Vec3(-shouldersDistance / 2, 0, upperBodyLength / 2),
            pivotB: new CANNON.Vec3(upperArmLength / 2, 0, 0),
            axisA: CANNON.Vec3.UNIT_X,
            axisB: CANNON.Vec3.UNIT_X,
            angle: angleShoulders,
            twistAngle,
            })
            constraints.push(leftShoulder)
            constraints.push(rightShoulder)

            // Elbow joint
            const leftElbowJoint = new CANNON.ConeTwistConstraint(lowerLeftArm, upperLeftArm, {
            pivotA: new CANNON.Vec3(-lowerArmLength / 2, 0, 0),
            pivotB: new CANNON.Vec3(upperArmLength / 2, 0, 0),
            axisA: CANNON.Vec3.UNIT_X,
            axisB: CANNON.Vec3.UNIT_X,
            angle,
            twistAngle,
            })
            const rightElbowJoint = new CANNON.ConeTwistConstraint(lowerRightArm, upperRightArm, {
            pivotA: new CANNON.Vec3(lowerArmLength / 2, 0, 0),
            pivotB: new CANNON.Vec3(-upperArmLength / 2, 0, 0),
            axisA: CANNON.Vec3.UNIT_X,
            axisB: CANNON.Vec3.UNIT_X,
            angle,
            twistAngle,
            })
            constraints.push(leftElbowJoint)
            constraints.push(rightElbowJoint)

            // bodies.forEach((body) => {
            //     body.collisionFilterGroup = EVERYTHING_ELSE_GROUP
            //     body.collisionFilterMask = PLAYER_GROUP | EVERYTHING_ELSE_GROUP
            // })

            return { bodies, constraints }
        }

    </script>
</body>
</html>