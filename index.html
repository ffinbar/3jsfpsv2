<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <title>Three.js Project</title>
    <style>
         .material-symbols-outlined {
          font-variation-settings:
          'FILL' 1,
          'wght' 400,
          'GRAD' 0,
          'opsz' 24
        }

        * {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body { margin: 0; }
        canvas { display: block; }

        h1 {
            font-size: 2em;
            margin-bottom: 1em;
            color: white;
        }

        h2,h3 {
            color: white;
        }

        #overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            background: transparent;
            border: none;
            border-radius: 50%;
            z-index: 2;
            margin-left: -5px;
            margin-top: -5px;
            
        }

        #chchar {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5em;
            color: #ffffffb3;
            /* text-shadow: 0 0 2px #000000; */
        }

        #pauseMenu {
            position: absolute;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: all;
            background-color: #3d3f85;
        }

        #pauseMenu section {
            display: flex;
            flex-direction: column;
            background: #00000082;
            color: white;
            padding: 2em;
            max-width: 40vw;
            max-height: 80vh;
            overflow-y: auto;
            width: 100%;
            border-radius: 1em;
            box-shadow: 0 0 10px 0 #00000082;
        }

        #pauseMenu section button {
            margin: 0.5em;
            padding: 0.5em;
            border: none;
            background: #00000082;
            color: white;
            font-size: 1.5em;
            cursor: pointer;
        }

        #pauseMenu section p {
            margin: 0.5em;
            font-size: 1.2em;
        }

        #pauseMenu section button:hover {
            background: #000000a1;
        }

        #pauseMenu section button:active {
            background: #000000c1;
        }

        #settingsList {
            display: flex;
            flex-direction: column;
            gap: 1em;
            font-size: 1.2em;
        }

        select, input[type="range"] {
            width: 100%;
        }

        select {
            padding: 0.5em;
        }

    </style>
</head>
<body>
    <div id="pauseMenu">
        <h1>ThreeJS FPS</h1>
        <h2 style="margin-bottom: 1rem;">Work In Progress</h2>
        <section id="pauseDefault" style="display: none;">
            <h1>Paused</h1>
            <button id="resume">Play</button>
            <button id="settings">Settings</button>
            <button id="controls">Controls</button>
            <button id="restart">Restart</button>
        </section>
        <section id="settingsMenu" style="display: none;">
            <h1>Settings</h1>
            <div id="settingsList">
                <!-- <label for="sensitivity">Mouse Sensitivity: <span id="sensitivityValue">0.5</span></label>
                <input type="range" id="sensitivity" min="0.1" max="1" step="0.1" value="0.5"> -->
                <h2>Presets</h2>
                <label for="quality">Quality</label>
                <select id="quality">
                    <option value="high">High</option>
                    <option value="medium">Medium</option>
                    <option value="low">Low</option>
                </select>
                <h2>Game</h2>
                <label for="volume">Volume: <span id="volumeValue">0.5</span></label>
                <input type="range" id="volume" min="0" max="1" step="0.1" value="0.5">

                <h2>Player</h2>
                <label for="moveSpeed">Move Speed: <span id="moveSpeedValue">0.5</span></label>
                <input type="range" id="moveSpeed" min="0" max="10" step="0.5" value="0.5">
                
                <label for="jumpHeight">Jump Height: <span id="jumpHeightValue">15</span></label>
                <input type="range" id="jumpHeight" min="0" max="50" step="1" value="15">

                <h2>World</h2>
                <label for="dayLength">Day Length (minutes): <span id="dayLengthValue">3</span></label>
                <input type="range" id="dayLength" min="0.5" max="10" step="0.5" value="3">
                
                <h2>Graphics</h2>
                <label for="fov">Field of View: <span id="fovValue">85</span></label>
                <input type="range" id="fov" min="30" max="120" step="1" value="85">
                
                <label for="bloomStr">Bloom Strength: <span id="bloomStrValue">0.2</span></label>
                <input type="range" id="bloomStr" min="0" max="3" step="0.1" value="0.2">

                <label for="bloomRadius">Bloom Radius: <span id="bloomRadiusValue">1</span></label>
                <input type="range" id="bloomRadius" min="0" max="3" step="0.1" value="1">

                <label for="bloomThreshold">Bloom Threshold: <span id="bloomThresholdValue">2.6</span></label>
                <input type="range" id="bloomThreshold" min="0" max="3" step="0.1" value="2.6">
                
                <label for="exposure">Exposure: <span id="exposureValue">0.3</span></label>
                <input type="range" id="exposure" min="0" max="1" step="0.1" value="0.3">

                <label for="environmentUpdateSpeed">Environment Update Speed (seconds): <span id="environmentUpdateSpeedValue">0.3</span></label>
                <input type="range" id="environmentUpdateSpeed" min="0" max="10.1" step="0.1" value="0.3">
                
                
                
                <label for="shadows">Shadows</label>
                <select id="shadows">
                    <option value="high">High</option>
                    <option value="medium">Medium</option>
                    <option value="low">Low</option>
                    <option value="off">Off</option>
                </select>
                
            </div>
            <button class="back">Back</button>
        </section>
        <section id="controlsList">
            <h1>Controls</h1>
            <div>
                <p>Use <b>WASD</b> to move</p>
                <p>Press <b>Space</b> to jump</p>
                <p>Press <b>C</b> to toggle crouch</p>
                <p>Press <b>E</b> when you see <span class="material-symbols-outlined">pan_tool</span> to grab an object</p>
                <p>Press <b>E</b> again to release the object</p>
                <p>Press <b>F</b> when you see <span class="material-symbols-outlined">touch_app</span> to interact with an object</p>
                <p>Press <b>F</b> again to stop interacting with the object</p>
                <p>Scrolling while holding an object will move it closer or further away</p>
                <p>Press <b>L</b> for flashlight</p>
            </div>
            <button class="back">Ok</button>
        </section>
        
    </div>

    <script>
        


    </script>

    <div id="overlay">
        
        <span id="chchar" class="material-symbols-outlined" style="display: none;">
        fiber_manual_record
        </span>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
                "cannon-es": "https://unpkg.com/cannon-es/dist/cannon-es.js"
            }

        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es'
        import CannonDebugger from './node_modules/cannon-es-debugger/dist/cannon-es-debugger.js';
        // import { OrbitControls } from './node_modules/three/examples/jsm/controls/OrbitControls.js';
        import { PointerLockControlsCannon } from './pointerLockControlsCannon.js';
        import Stats from './node_modules/three/examples/jsm/libs/stats.module.js';
        import { GLTFLoader } from './node_modules/three/examples/jsm/loaders/GLTFLoader.js';
        import {threeToCannon, ShapeType} from './node_modules/three-to-cannon/dist/three-to-cannon.modern.js';
        import { EffectComposer } from './node_modules/three/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from './node_modules/three/examples/jsm/postprocessing/RenderPass.js';
        import { OutlinePass } from './node_modules/three/examples/jsm/postprocessing/OutlinePass.js';
        import { OutputPass } from './node_modules/three/examples/jsm/postprocessing/OutputPass.js';
        import { Sky } from './node_modules/three/examples/jsm/objects/Sky.js'
        import { GUI } from './node_modules/three/examples/jsm/libs/lil-gui.module.min.js'
        import {GLTFExporter} from './node_modules/three/examples/jsm/exporters/GLTFExporter.js';
        import {ImprovedNoise } from './node_modules/three/examples/jsm/math/ImprovedNoise.js';
        import { UnrealBloomPass } from './node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js';
        import { DecalGeometry } from './node_modules/three/examples/jsm/geometries/DecalGeometry.js';
        import { Colt } from './assets/colt.js'
        import { M4 } from './assets/m4.js'

        const width = window.innerWidth, height = window.innerHeight;

        let isPaused = true;

        let timeStep = 1 /144; // seconds
        let lastCallTime = performance.now() /1000
        let pausedTime = 0
        let pauseStartTime;

        let dayLength = 3*60;

        let scene, camera, renderer, composer, controls, stats, outlinePass = {};
        let currentRenderer = renderer;
        let bloomPass;
        outlinePass.selectedObjects = [];
        let sunLight, sunTarget, sunHelper;
        let sky, sun;
        let sunUpdateInterval;
        let defaultMaterial, defaultGeometry, defaultRadius;
        let world, cannonDebugger;
        let slipMaterial;
        let player = {};
        player.equipped = null;
        let playerBody, playerMesh, playerShape, playerMaterial;
        let isGrabbing = false;
        let moveSpeed = 10;
        let grabbedObject = null;
        let grabBody = {};
        let yawBody, handBody;
        let grabConstraint, jointBody;

        let textureLoader = new THREE.TextureLoader();
        let decalMat;

        let crosshairStates = {
            look: 'fiber_manual_record',
            grab: 'pan_tool',
            interact: 'touch_app',
            none: 'block'
        }

        let pauseMenu = document.getElementById('pauseMenu');
        let menuDefault = document.getElementById('pauseDefault'), 
        resumeBtn = document.getElementById('resume'),
        settingsBtn = document.getElementById('settings'),
        controlsBtn = document.getElementById('controls'), 
        restartBtn = document.getElementById('restart'),
        settingsMenu = document.getElementById('settingsMenu'),
        controlsList = document.getElementById('controlsList'),
        backBtns = document.querySelectorAll('.back'),
        crosshair = document.getElementById('chchar');

        let settings = {};

        let scrollDirection = 0; // 0: no scroll, 1: scroll up, -1: scroll down

        let mixers = [];

        const PLAYER_GROUP = 1 << 0; // 0001 in binary
        const EVERYTHING_ELSE_GROUP = 1 << 1; // 0010 in binary

        let starMesh, starMaterial;
        let cubeCamera, cubeRenderTarget;

        let spotLight, spotLightHelper, spotLightTarget;

        let keys = {};
        let mouse = {};

        let colt = {};

        let listener = null;
        let audioLoader = new THREE.AudioLoader();
        let stepSound = null;

        const meshMap = new Map();
        
        init();

        async function init() {
            settingsSetup();

            // init
            sceneSetup();
            cameraSetup();
            rendererSetup();

            setCrosshair('look');
            
            statsSetup();
            physicsSetup();
            createObjects();
            lightSetup();
            
            
            
            inputSetup();
            createPlayer();
            controlsSetup();
            skySetup();
            

            
            // carSetup();
            
        }

        function settingsSetup() {
            // settingsList setup
            const settingsList = document.getElementById('settingsList');
            settings = {}

            settingsList.querySelectorAll('input, select').forEach(setting => {
            settings[setting.id] = setting;
            });

            console.log(settings)

            for (const setting in settings) {
                settings[setting].addEventListener('input', () => {
                    updateSetting(setting);
                }) 
            }

            //player

            settings.moveSpeed.addEventListener('input', () => {
            updateMoveSpeed();
            })

            settings.jumpHeight.addEventListener('input', () => {
            updateJumpHeight();
            })

            //

            settings.volume.addEventListener('input', () => {
            updateVolume(parseFloat(settings.volume.value));
            })

            settings.dayLength.addEventListener('input', () => {
            updateDayLength();
            })

            settings.fov.addEventListener('input', () => {
            updateFov();
            })

            settings.bloomStr.addEventListener('input', () => {
            updateBloomSettings(parseFloat(settings.bloomStr.value), null, null);
            })

            settings.bloomRadius.addEventListener('input', () => {
            updateBloomSettings(null, parseFloat(settings.bloomRadius.value), null);
            })

            settings.bloomThreshold.addEventListener('input', () => {
            updateBloomSettings(null, null, parseFloat(settings.bloomThreshold.value));
            })

            settings.exposure.addEventListener('input', () => {
            updateExposure(parseFloat(settings.exposure.value));
            })

            settings.environmentUpdateSpeed.addEventListener('input', () => {
            updateEnvironmentUpdateSpeed(settings.environmentUpdateSpeed.value);
            })

            settings.quality.addEventListener('input', () => {
                switch (settings.quality.value) {
                    case 'high':
                        renderer.shadowMap.enabled = true;
                        bloomPass.enabled = true;
                        updateEnvironmentUpdateSpeed(0.3);
                        currentRenderer = composer;
                        sunLight.shadow.mapSize.width = 2048
                        sunLight.shadow.mapSize.height = 2048
                        break;
                    case 'medium':
                        renderer.shadowMap.enabled = true;
                        bloomPass.enabled = true;
                        updateEnvironmentUpdateSpeed(3);
                        currentRenderer = composer;
                        sunLight.shadow.mapSize.width = 1024
                        sunLight.shadow.mapSize.height = 1024
                        break;
                    case 'low':
                        renderer.shadowMap.enabled = false;
                        bloomPass.enabled = false;
                        updateEnvironmentUpdateSpeed(10.1);
                        currentRenderer = renderer;
                        sunLight.shadow.mapSize.width = 512;
                        sunLight.shadow.mapSize.height = 512;

                        break;
                }
                currentRenderer === composer ? composer.render() : renderer.render(scene, camera);
            })
        }

        function updateSetting(setting) {
            //if not a select element
            if (settings[setting].type !== 'select-one') {
            document.getElementById(`${setting}Value`).textContent = settings[setting].value;
            }
        }

        function updateMoveSpeed(overrideValue = null) {
            moveSpeed = overrideValue !== null ? parseFloat(overrideValue) : parseFloat(settings.moveSpeed.value);
            if(controls) {
            controls.velocityFactor = moveSpeed;
            console.log(controls.velocityFactor)
            }
        }

        function updateVolume(overrideValue = null) {
            if(listener) {
            listener.setMasterVolume(overrideValue !== null ? overrideValue : parseFloat(settings.volume.value));
            }
        }

        function updateJumpHeight(overrideValue = null) {
            controls.jumpVelocity = overrideValue !== null ? parseFloat(overrideValue) : parseFloat(settings.jumpHeight.value);
        }

        function updateDayLength(overrideValue = null) {
            dayLength = overrideValue !== null ? parseFloat(overrideValue) * 60 : parseFloat(settings.dayLength.value) * 60;
        }

        function updateFov(overrideValue = null) {
            camera.fov = overrideValue !== null ? parseFloat(overrideValue) : parseFloat(settings.fov.value);
            camera.updateProjectionMatrix();
            if(composer) {
            composer.setSize(window.innerWidth, window.innerHeight);
            composer.render();
            }
        }

        function updateBloomSettings(strength = null, radius = null, threshold = null) {
            if (strength !== null) {
            bloomPass.strength = strength;
            }
            if (radius !== null) {
            bloomPass.radius = radius;
            }
            if (threshold !== null) {
            bloomPass.threshold = threshold;
            }
            composer.render();
        }

        function updateExposure(overrideValue = null) {
            renderer.toneMappingExposure = overrideValue !== null ? parseFloat(overrideValue) : parseFloat(settings.exposure.value);
            composer.render();
        }

        function updateEnvironmentUpdateSpeed(overrideValue = null) {
            let value = overrideValue !== null ? overrideValue : parseFloat(settings.environmentUpdateSpeed.value);

            if(sunUpdateInterval && cubeCamera) {
            if(value == 10.1) {
                clearInterval(sunUpdateInterval);
                document.getElementById(`environmentUpdateSpeedValue`).textContent = 'Off';
            } else {
                clearInterval(sunUpdateInterval);
                sunUpdateInterval = setInterval(function() {
                cubeCamera.update(renderer, scene)
                }, value * 1000);
            }
            }
        }

        
        function setCrosshair(state) {
            crosshair.textContent = crosshairStates[state];
        }

        function resume() {
            controls.lock();
            // pauseStartTime = performance.now();
            
            
        }

        function sceneSetup() {
            // scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color( 0x87ceeb );

            scene.fog = new THREE.Fog( 0x000000, 1, 200 );

            textureLoader.load('assets/decal.png', function(texture) {
                decalMat = new THREE.MeshBasicMaterial({ 
                    map: texture, 
                    transparent: true,
                    depthTest: true,
                    depthWrite: false,
                    polygonOffset: true,
                    polygonOffsetFactor: 1,
                    wireframe: false
                 });
            });

        }

        function cameraSetup() {
            // camera
            camera = new THREE.PerspectiveCamera( 85, width / height, 0.01, 1000 );
           
            camera.lookAt(0, 0, 0);

            player.hand = new THREE.Object3D();
            camera.add(player.hand);
            player.hand.position.set(0, 0, -3);
            
            player.anim = {};

            player.anim.grabDest = new THREE.Object3D();
            camera.add(player.anim.grabDest);
            player.anim.grabDest.position.set(0.1, 0, -0.4);
            player.anim.grabDest.resetPosition = player.anim.grabDest.position.clone();
            createDebugSphere(player.anim.grabDest.getWorldPosition(new THREE.Vector3()), 0.1, 0x00ff00);
            console.log(player)

            window.addEventListener('click', () => {
                listener = new THREE.AudioListener();
                camera.add(listener);

                stepSound = new THREE.Audio(listener);
                audioLoader.load('assets/sound/step1.mp3', function(buffer) {
                    stepSound.setBuffer(buffer);
                    stepSound.setLoop(false);
                    stepSound.setVolume(0.5);
                    // stepSound.play();
                    player.yawObject.add(stepSound);
                });
            }, { once: true });

        }

        function rendererSetup() {
            // renderer
           
            renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true, stencilBuffer: true });
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.setAnimationLoop( animate );
            renderer.outputEncoding = THREE.sRGBEncoding;
            
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.VSMShadowMap;

            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.3;
            
            document.body.appendChild( renderer.domElement );

            
            composer = new EffectComposer(renderer);
            currentRenderer = composer;
            composer.addPass(new RenderPass(scene, camera));

            bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.2, 1, 2.6);
            composer.addPass(bloomPass);

            // outlinePass = new OutlinePass(new THREE.Vector2(1, 1), scene, camera);
            // outlinePass.edgeStrength = 3.0;
            // outlinePass.edgeGlow = 1.0;
            // outlinePass.edgeThickness = 1.0;
            // outlinePass.pulsePeriod = 0;
            // outlinePass.usePatternTexture = false;
            // outlinePass.visibleEdgeColor.set('#ffffff');
            // outlinePass.hiddenEdgeColor.set('#190a05');
            // composer.addPass(outlinePass);
        
            const outputPass = new OutputPass();
            composer.addPass(outputPass);
        }

        function lightSetup() {
            // lights
            // const light = new THREE.DirectionalLight( 0xffffff, 1 );
            // light.position.set( 5, 5, 5 );
            // light.castShadow = true;
            // light.shadow.mapSize.width = 1024;
            // light.shadow.mapSize.height = 1024;
            // light.shadow.camera.near = 0.5;
            // light.shadow.camera.far = 500;

            // scene.add( light );

            // const ambientLight = new THREE.AmbientLight( 0xffffff, 0.5 );
            // scene.add( ambientLight );

            sunLight = new THREE.DirectionalLight(0xFFFFFF, 5);
            sunLight.position.set(5, 10, 5);
            sunLight.castShadow = true;
            sunLight.shadow.bias = -0.0001;
            const size = 100; 
            sunLight.shadow.camera.left = -size;
            sunLight.shadow.camera.right = size;
            sunLight.shadow.camera.top = size;
            sunLight.shadow.camera.bottom = -size;
            sunLight.shadow.mapSize.width = 2048; // Default is 512
            sunLight.shadow.mapSize.height = 2048; // Default is 512
            // sunLight.shadow.radius = 1;

            sunTarget = new THREE.Object3D();
            sunTarget.position.set(0, 0, 0);

            spotLightTarget = new THREE.Object3D();
            spotLightTarget.position.set(0, 0, -13);
            camera.add(spotLightTarget);


            sunLight.target.position.set(sunTarget.position.x, sunTarget.position.y, sunTarget.position.z);
            scene.add(sunLight);

            let debugSun = new THREE.DirectionalLight(0xFFFFFF, 3);
            debugSun.position.set(5, 10, 5);
            // debugSun.target = (new THREE.Object3D()).position.set(0, 0, 0);
            // scene.add(debugSun);

            // sunHelper = new THREE.DirectionalLightHelper(sunLight, 5);
            // scene.add(sunHelper);

            spotLight = new THREE.SpotLight(0xFFFFFF, 0);
            spotLight.position.set(0, 0, -0.1);
            spotLight.target = spotLightTarget;
            spotLight.angle = Math.PI / 4;
            spotLight.penumbra = 0.3;
            spotLight.decay = 0.7;
            spotLight.distance = 10;

            spotLight.castShadow = false;

            camera.add(spotLight);

            

            // spotLightHelper = new THREE.SpotLightHelper(spotLight);
            // scene.add(spotLightHelper);


        }

        function skySetup() {
            sky = new Sky();
            sky.scale.setScalar( 450000 );
            scene.add( sky );
            

            sun = new THREE.Vector3();


            cubeRenderTarget = new THREE.WebGLCubeRenderTarget( 16 );
            cubeRenderTarget.texture.type = THREE.HalfFloatType;

            cubeCamera = new THREE.CubeCamera( 100, 100, cubeRenderTarget );
            
            //

            let material = new THREE.MeshStandardMaterial( {
                envMap: cubeRenderTarget.texture,
                roughness: 0,
                metalness: 1
            } );

            const geometry = new THREE.SphereGeometry( 1, 8, 8 );
            const mesh = new THREE.Mesh( geometry, material );
            scene.add( mesh );
            mesh.position.set(0, 20, 0);
            cubeCamera.position.copy( mesh.position );
            scene.environment = cubeRenderTarget.texture;

            // stars setup
            //material:

            const starCanvas = document.createElement( 'canvas' );
            starCanvas.width = 1012;
            starCanvas.height = 1012;
            const starCtx = starCanvas.getContext( '2d' );

            // draw stars
            for (let i = 0; i < 5000; i++) {
                const x = Math.random() * starCanvas.width;
                const y = Math.random() * starCanvas.height;
                const size = Math.random() * 0.1;
                starCtx.fillStyle = 'white'
                starCtx.beginPath();
                starCtx.arc(x, y, size, 0, 2 * Math.PI);
                starCtx.fill();
            }

            // star texture
            const starTexture = new THREE.CanvasTexture( starCanvas );
            starTexture.mapping = THREE.UVMapping;

            // star material
            starMaterial = new THREE.MeshStandardMaterial(
                { map: starTexture, side: THREE.BackSide, transparent: true, opacity: 0, emissive: 0xffffff, emissiveIntensity: 100 } );

            const starGeometry = new THREE.SphereGeometry( 100,  8, 8 );


            starMesh = new THREE.Mesh( starGeometry, starMaterial );
            scene.add( starMesh );

            starMesh.position.copy(controls.getObject().position);

            /// Set initial values

            const effectController = {
                turbidity: 10,
                rayleigh: 3,
                mieCoefficient: 0.005,
                mieDirectionalG: 0.975,
                elevation: 0,
                azimuth: 180,
                exposure: renderer.toneMappingExposure
            };

            function setSky() {

                const uniforms = sky.material.uniforms;
                uniforms[ 'turbidity' ].value = effectController.turbidity;
                uniforms[ 'rayleigh' ].value = effectController.rayleigh;
                uniforms[ 'mieCoefficient' ].value = effectController.mieCoefficient;
                uniforms[ 'mieDirectionalG' ].value = effectController.mieDirectionalG;

                const phi = THREE.MathUtils.degToRad( 90 - effectController.elevation );
                const theta = THREE.MathUtils.degToRad( effectController.azimuth );

                sun.setFromSphericalCoords( 1, phi, theta );

                // sunLight.position.copy(sun);

                uniforms[ 'sunPosition' ].value.copy( sun );


                // Calculate the zenith angle cosine
                const sunDirection = new THREE.Vector3().copy(sunLight.position).normalize();
                const zenithAngleCos = sunDirection.y; // Assuming the up direction is (0, 1, 0)

                // Calculate the sun intensity
                const intensity = sunIntensity(zenithAngleCos);

                // Set the light intensity
                sunLight.intensity = intensity
                // console.log(sunLight.intensity);

                composer.render()



            }

            setSky();
            
            sunUpdateInterval = setInterval(function() {
                
                if(controls.enabled) {

                
                    cubeCamera.update(renderer, scene)
                }
                
                
            }, 300);
            
                        
        }

        function calculateSunPosition(time) {
            
            const dayDuration = dayLength; // seconds in a day
            const dayTime = time % dayDuration;
            let dayPercentage = (dayTime / dayDuration) % 1
            
            const elevation = (dayPercentage * 360) % 360;

            // console.log(elevation, dayPercentage)
            

            const azimuth = 90


            return { elevation, azimuth, dayPercentage };
        }

        function updateSunPosition(time) {
            const { elevation, azimuth, dayPercentage } = calculateSunPosition(time);    

            const phi = THREE.MathUtils.degToRad( 90 - elevation );
            const theta = THREE.MathUtils.degToRad( azimuth );

            sun.setFromSphericalCoords( 20, phi, theta );
            sunLight.position.copy(sun);

            sky.material.uniforms[ 'sunPosition' ].value.copy( sun );

            starMesh.rotation.z = -phi /4;
            
            if (dayPercentage >= 0.5 && dayPercentage < 0.75) {
                starMaterial.opacity = (dayPercentage - 0.5) * 4;
            } else if (dayPercentage >= 0.75 && dayPercentage < 1) {
                starMaterial.opacity = (1 - dayPercentage) * 4;
            } else {
                starMaterial.opacity = 0;
            }
            // console.log(starMaterial.opacity, dayPercentage)

            // Calculate the zenith angle cosine
            const sunDirection = new THREE.Vector3().copy(sunLight.position).normalize();
            const zenithAngleCos = sunDirection.y; // Assuming the up direction is (0, 1, 0)

            // Calculate the sun intensity
            const intensity = sunIntensity(zenithAngleCos);

            // Set the light intensity
            sunLight.intensity = intensity

            // console.log(sunLight.intensity);
            // sunHelper.update();
        }

        function sunIntensity(zenithAngleCos) {
            const cutoffAngle = 1.6110731556870734;
            const steepness = 1.5;
            const EE = 10.0;

            zenithAngleCos = Math.max(-1, Math.min(1, zenithAngleCos));
            return EE * Math.max(0, 1 - Math.exp(-(cutoffAngle - Math.acos(zenithAngleCos)) / steepness));
        }






        async function controlsSetup() {
            // controls
          

            controls = new PointerLockControlsCannon(camera, playerBody)
            scene.add(controls.getObject())

            player.pitchObject = controls.getObject().children[0];
            player.pitchObject.position.set(0, 1, 0);

            controls.yawObject.rotation.y = Math.PI;


            window.addEventListener('click', () => {
                controls.stepSound = stepSound;
            }, { once: true })
            
            //heavy body is mesh called heavy_arm
            // let playerScene = await loadGLTF('assets/heavy.glb', 1)
            // console.log(playerScene)
            // player.model = playerScene.scene.children[0];
            // player.model.frustumCulled = false;
            // player.model.traverse(child => {
            //     child.frustumCulled = false;
            // });

            // const mixer = new THREE.AnimationMixer(player.model);
            // player.mixer = mixer;
            // mixers.push(mixer);

            // player.actions = player.actions || {};
            // for (const animation of playerScene.animations) {
            //     const action = mixer.clipAction(animation);
            //     console.log(animation)
            //     if (animation.name !== 'idle') {
            //         action.setEffectiveWeight(0);
            //     }
            //     player.actions[animation.name] = action;
            // }
            
            // console.log(player)

            // player.actions['idle'].play();

            // player.idleClip = player.actions['idle'].getClip();
            // player.grabClip = player.actions['grab_add'].getClip();
            // player.walkClip = player.actions['walk'].getClip();
            // player.jumpClip = player.actions['jump'].getClip();
            // player.fallClip = player.actions['fall'].getClip();
            
            // THREE.AnimationUtils.makeClipAdditive(player.grabClip, 0, player.idleClip, 30);
            // THREE.AnimationUtils.makeClipAdditive(player.walkClip, 0, player.idleClip, 30);
            // THREE.AnimationUtils.makeClipAdditive(player.jumpClip, 0, player.idleClip, 30);
            // THREE.AnimationUtils.makeClipAdditive(player.fallClip, 0, player.idleClip, 30);
            
            // let additiveGrabAddAction = player.mixer.clipAction(player.grabClip);
            // let additiveWalkAction = player.mixer.clipAction(player.walkClip);
            // let additiveJumpAction = player.mixer.clipAction(player.jumpClip);
            // let additiveFallAction = player.mixer.clipAction(player.fallClip);
            

            // player.actions['grab_add'] = additiveGrabAddAction;
            // player.actions['walk'] = additiveWalkAction;
            // player.actions['jump'] = additiveJumpAction;
            // player.actions['fall'] = additiveFallAction;
        
            // player.actions['grab_add'].setEffectiveWeight(0);
            // player.actions['grab_add'].play();
            // player.actions['walk'].setEffectiveWeight(0);
            // player.actions['walk'].play();
            // player.actions['jump'].setEffectiveWeight(0);
            // player.actions['jump'].setLoop(THREE.LoopOnce);
            // player.actions['jump'].play();
            // player.actions['fall'].setEffectiveWeight(0);
            // player.actions['fall'].play();
            // player.actions['idle'].play();
            // player.actions['grab_add'].setEffectiveWeight(1);
            // player.actions['grab_add'].play()
            // console.log(player.actions['idle'].getClip())
            // player.actions['idle'].fadeOut(1);

            // player.actions['grab_add'].blendMode = THREE.AdditiveAnimationBlendMode
            // player.actions['grab_add'].fadeIn(0.1);
            // player.actions['grab_add'].crossFadeFrom(player.actions['idle'], 1, false).play()
            // console.log(player.actions['idle'])

            player.yawObject = controls.getObject();

            // player.yawObject.add(player.model);
            // player.model.scale.set(0.7, 0.7, 0.7 );
            // player.model.position.set(0, -0.2, -.1);

            yawBody = new CANNON.Body({
                mass: 0,
                shape: new CANNON.Box(new CANNON.Vec3(0.1, 0.1, 0.1)),
                collisionResponse: true,
            })
            yawBody.position.set(0, 0, 0);
            world.addBody(yawBody);

            ragdollSetup(true, 0.5, 0.01)


            window.addEventListener('click', () => {
                if (!isPaused) {
                    controls.enabled = true
                    controls.lock()
                }
            })

            controls.addEventListener('lock', () => {
                isPaused = false;
                controls.enabled = true
                
                if (pauseStartTime !== undefined) {
                    pausedTime += performance.now() - pauseStartTime;
                }
                pauseStartTime = undefined;
                crosshair.style.display = null;
                pauseMenu.style.display = 'none';

                // animate()
                // instructions.style.display = 'none'
            })

            controls.addEventListener('unlock', () => {
                controls.enabled = false
                isPaused = true;
                pauseStartTime = performance.now();
                pauseMenu.style.display = null;
                crosshair.style.display = 'none';
                // instructions.style.display = null
            })
        }

        function fadeOutAnimation(determiner, action, duration) {
            if (determiner && action && action.weight > 0) {
                // console.log('fading out')
                // action.fadeOut(duration || 0.1);
            }

        }

        function fadeInAnimation(determiner, action, duration) {
            if (determiner && action && action.weight < 1) {
                // console.log('fading in', action.weight)
                // action.fadeIn(duration || 0.1);
            }
        }

        function statsSetup() {
            // stats
            stats = new Stats();
            document.body.appendChild( stats.dom );
        }

        function physicsSetup() {
            // physics
            world = new CANNON.World({
                gravity: new CANNON.Vec3(0, -9.82, 0), // m/s²
            })

            world.allowSleep = true
            // world.solver.iterations = 10

            cannonDebugger = new CannonDebugger(scene, world, {
                onInit(body, mesh) {
                    // Toggle visibiliy on "d" press
                    mesh.visible = false
                    document.addEventListener('keydown', (event) => {
                    if (event.key === '=') {
                        mesh.visible = !mesh.visible
                    }
                    })
                },
            })

            slipMaterial = new CANNON.Material('slippery')
            slipMaterial.friction = 0

            handBody = new CANNON.Body({
                mass: 0,
                shape: new CANNON.Sphere(0.1),
                collisionResponse: false,
            })
            handBody.position.set(0, 0, 0)
            world.addBody(handBody)


        }
        
        async function createObjects() {
            // objects
            defaultMaterial = new THREE.MeshNormalMaterial();
            defaultGeometry = new THREE.BoxGeometry( 0.2, 0.2, 0.2 );
            defaultRadius = 1;
            let defaultHitSfx;

            window.addEventListener('click', () => {
                defaultHitSfx = new THREE.PositionalAudio( listener );
                audioLoader.load( 'assets/sound/ricochet1.mp3', function( buffer ) {
                    
                    defaultHitSfx.setBuffer( buffer );
                    defaultHitSfx.setRefDistance( 5 );
                    defaultHitSfx.setVolume(0.5)
                    // defaultHitSfx.play()
                    scene.add(defaultHitSfx);
                });
                sphereMesh.hitSound = defaultHitSfx;

            
            }, { once: true });

            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry( 50, 50, 50, 50 ),
                new THREE.MeshStandardMaterial( { color: 0x808080, side: THREE.DoubleSide } )
            );

            floor.receiveShadow = true;

            floor.rotation.x = - Math.PI / 2;
            floor.position.y = -1;
            scene.add( floor );

            const floorBody = new CANNON.Body({
                mass: 0, // make it static
                shape: new CANNON.Box(new CANNON.Vec3(50, 0.1, 50)), // 20x2x20 size box
                collisionFilterGroup: EVERYTHING_ELSE_GROUP,
                collisionFilterMask: EVERYTHING_ELSE_GROUP | PLAYER_GROUP,
            });
            floorBody.position.set(0, -1.1, 0); // m
            world.addBody(floorBody);


            // const groundBody = new CANNON.Body({
            //     type: CANNON.Body.STATIC, // can also be achieved by setting the mass to 0
            //     shape: new CANNON.Plane(),
            //     collisionFilterGroup: EVERYTHING_ELSE_GROUP,
            //     collisionFilterMask: PLAYER_GROUP | EVERYTHING_ELSE_GROUP,
            // })

            // groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0) // make it face up
            // groundBody.position.set(0, -3, 0) // m

            // groundBody.name = 'floor'
            // world.addBody(groundBody)

            const sphereBody = new CANNON.Body({
                mass: 5, // kg
                shape: new CANNON.Sphere(defaultRadius),
                collisionFilterGroup: EVERYTHING_ELSE_GROUP,
                collisionFilterMask: PLAYER_GROUP | EVERYTHING_ELSE_GROUP,
            })
            sphereBody.position.set(0, 10, 0) // m
            world.addBody(sphereBody)

            sphereBody.damping = 0.9
            sphereBody.angularDamping = 0.99
            sphereBody.name = 'sphere'

            const geometry = new THREE.SphereGeometry(defaultRadius)
            const sphereMesh = new THREE.Mesh(geometry, defaultMaterial)
            scene.add(sphereMesh)

            meshMap.set(sphereBody, sphereMesh)

            const boxBody = new CANNON.Body({
                mass: 5, // kg
                shape: new CANNON.Box(new CANNON.Vec3(0.1, 0.1, 0.1)), // m
                collisionFilterGroup: EVERYTHING_ELSE_GROUP,
                collisionFilterMask: PLAYER_GROUP | EVERYTHING_ELSE_GROUP,
            })
            boxBody.position.set(0, 5, 0) // m
            world.addBody(boxBody)
            boxBody.name = 'box'
            
            const box = new THREE.Mesh( defaultGeometry, defaultMaterial );
            scene.add( box );

            meshMap.set(boxBody, box)


            createDebugSphere(new THREE.Vector3(1, 5, -5), 10000, 0x00ff00);


            const size = 0.1
            const dist = size * 2 + 0.4
            const mass = 1
            const N = 4

            const sphereShape = new CANNON.Sphere(size)

            let finalBody;

            let previous
            for (let i = 0; i < N; i++) {
                // Create a new body
                const sphereBody = new CANNON.Body({ mass: i === 0 ? 0 : mass, angularDamping: 0.5, linearDamping: 0.5})
                sphereBody.addShape(sphereShape)
                sphereBody.position.set(1, 10 - (dist * (N - i)), -5)
                sphereBody.velocity.x = -i
                sphereBody.collisionFilterGroup = EVERYTHING_ELSE_GROUP;
                sphereBody.collisionFilterMask = PLAYER_GROUP | EVERYTHING_ELSE_GROUP;
                world.addBody(sphereBody)

                let sphereMesh = new THREE.Mesh(new THREE.SphereGeometry(size), defaultMaterial)
                scene.add(sphereMesh)
                meshMap.set(sphereBody, sphereMesh)

                // Connect this body to the last one added
                if (previous) {
                    const distanceConstraint = new CANNON.DistanceConstraint(sphereBody, previous, dist)
                    world.addConstraint(distanceConstraint)
                }

                // Keep track of the lastly added body
                previous = sphereBody

                if (i === N - 1) {
                    finalBody = sphereBody
            }
            }

            let sceneGltf = await loadGLTF('assets/simple.glb', 1)
            scene.add(sceneGltf.scene);
            console.log(sceneGltf.scene)

            let lampMesh = sceneGltf.scene.children.filter(child => child.name === 'lamp')[0];
            let lampBody;

            let lampLight = lampMesh.children.filter(child => child.name === 'Spot')[0];
            lampLight.castShadow = true;
            lampLight.shadow.bias = -0.0001;


            for (let [body, mesh] of meshMap.entries()) {
                if (mesh === lampMesh) {
                    lampBody = body;
                    break;
                }
            }
            console.log(lampBody)

            lampBody.angularDamping = 0.5;

            let lampConstraint = new CANNON.PointToPointConstraint(lampBody, new CANNON.Vec3(0, dist, 0), finalBody, new CANNON.Vec3(0, 0, 0), 1);
            world.addConstraint(lampConstraint)

            //guns


            let coltFireSound, coltRicochetSound;
            let colt;
            let m4FireSound;
            let m4;

            window.addEventListener('click', async () => {
                console.log('creating colt')

                let coltScene = await loadGLTF('assets/colt_1911.glb', 1)
                scene.add(coltScene.scene)
                console.log(coltScene)
                let coltObject = coltScene.scene.children[0];
                coltObject.receiveShadow = true;
                coltObject.castShadow = true;

                let coltFireFrom = coltObject.children[0];
                let coltFlashObj = coltObject.children[1];
                let coltMuzzle = coltObject.children[2];
                coltMuzzle.intensity = 0;
                coltMuzzle.castShadow = true;
                coltFlashObj.visible = false;
                coltFlashObj.backface = true;
                let coltBody;

                for (let [body, mesh] of meshMap.entries()) {
                    if (mesh === coltObject) {
                        coltBody = body;
                        // coltBody.mass = 0;
                        break;
                    }
                }

                console.log('loaded sound')
                coltFireSound = new THREE.PositionalAudio( listener );
                audioLoader.load( 'assets/sound/colt_fire.mp3', function( buffer ) {
                    
                    coltFireSound.setBuffer( buffer );
                    coltFireSound.setRefDistance( 20 );
                    // coltFireSound.loop = true

                    // coltFireSound.play()
                    coltFireFrom.add( coltFireSound );
                });

                coltRicochetSound = new THREE.PositionalAudio( listener );
                audioLoader.load( 'assets/sound/ricochet2.mp3', function( buffer ) {
                    
                    coltRicochetSound.setBuffer( buffer );
                    coltRicochetSound.setRefDistance( 5 );
                    coltRicochetSound.setVolume(0.5)
                    // coltRicochetSound.play()
                    scene.add(coltRicochetSound);
                });

                colt = new Colt(player, scene, world, coltObject, coltBody, coltMuzzle, coltFireFrom, coltFlashObj, coltFireSound, coltRicochetSound, decal, decalMat, meshMap, EVERYTHING_ELSE_GROUP, PLAYER_GROUP, listener);
                console.log(colt)

                let m4Scene = await loadGLTF('assets/m4.glb', 1)
                scene.add(m4Scene.scene)
                console.log(m4Scene)
                let m4Object = m4Scene.scene.children[0];
                m4Object.receiveShadow = true;
                m4Object.castShadow = true;

                let m4FireFrom = m4Object.children.filter(child => child.name.endsWith('fireFrom'))[0];
                let m4FlashObj = m4Object.children.filter(child => child.name.endsWith('flashObj'))[0];
                let m4Muzzle = m4Object.children.filter(child => child.name.endsWith('muzzle'))[0];
                let m4lhPos = m4Object.children.filter(child => child.name.endsWith('lhPos'))[0];
                m4Muzzle.intensity = 0;
                m4Muzzle.castShadow = true;
                m4FlashObj.visible = false;
                m4FlashObj.backface = true;
                let m4Body;
                

                for (let [body, mesh] of meshMap.entries()) {
                    if (mesh === m4Object) {
                        m4Body = body;
                        // m4Body.mass = 0;
                        break;
                    }
                }

                m4FireSound = new THREE.PositionalAudio( listener );
                audioLoader.load( 'assets/sound/m4_fire.mp3', function( buffer ) {
                    
                    m4FireSound.setBuffer( buffer );
                    m4FireSound.setRefDistance( 20 );
                    // m4FireSound.loop = true

                    // m4FireSound.play()
                    m4FireFrom.add( m4FireSound );
                });

                m4 = new M4(player, scene, world, m4Object, m4Body, m4Muzzle, m4FireFrom, m4FlashObj, m4lhPos, m4FireSound, coltRicochetSound, decal, decalMat, meshMap, EVERYTHING_ELSE_GROUP, PLAYER_GROUP, listener);

                
            
            }, { once: true });

            

        }

        function decal(material, scale, position, rotation) {
            let transparentMaterial = new THREE.MeshBasicMaterial({transparent: true, opacity: 0});
            let materials = [
            transparentMaterial, // left
                transparentMaterial, // right
                transparentMaterial, // top
                transparentMaterial, // bottom
                material, // back
                transparentMaterial // front
            ];
            let decal = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 0.01), materials);
            decal.position.copy(position);
            decal.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), new THREE.Vector3(rotation.x, rotation.y, rotation.z));
            decal.scale.set(scale, scale, scale);
            
            return decal;
        }

        // function unequip() {
        //     if(player.equipped) {
        //         player.equipped.body.mass = player.equipped.body.originalMass;
        //         player.equipped.body.collisionResponse = true;
        //         player.equipped.body.collisionFilterGroup = EVERYTHING_ELSE_GROUP;
        //         player.equipped.body.collisionFilterMask = PLAYER_GROUP | EVERYTHING_ELSE_GROUP;
                
        //         player.anim.grabDest.position.copy(player.anim.grabDest.resetPosition);

        //         world.removeConstraint(player.handConstraint);
        //         world.removeConstraint(player.equipped.constraint);
        //         player.handConstraint = player.resetHandConstraint;

        //         player.equipped = null;
        //     }
        // }

        function equip(object) {
             
            console.log('equipping')
            isGrabbing = false; 
            removegrabConstraint();
            world.removeConstraint(player.handConstraint);

            object.parent.equip();
            grabbedObject = null;
        }

        function holdEquipped() {
            if(!player.equipped) return;

            // player.equipped.fireSound.position = player.equipped.fireFrom.getWorldPosition(new THREE.Vector3());
            
            player.equipped.body.quaternion.copy(player.anim.grabDest.body.quaternion);
            player.anim.grabDest.position.copy(player.equipped.grabPosition);

            let rotationQuaternion = new CANNON.Quaternion();
            rotationQuaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), -Math.PI / 2);

            player.equipped.body.quaternion = player.equipped.body.quaternion.mult(rotationQuaternion);
            
        }


        function inputSetup() {
            let keyDownListener = function(event) {
                event.preventDefault();
                // console.log(event.code);
                keys[event.code] = true;
                // console.log(keys);
            };

            let keyUpListener = function(event) {
                event.preventDefault();
                // console.log(event.code);
                keys[event.code] = false;
            };

            let mouseDownListener = function(event) {
                if (isPaused) return;
                event.preventDefault();
                mouse[event.button] = true;
            }

            let mouseUpListener = function(event) {
                if (isPaused) return;
                event.preventDefault();
                mouse[event.button] = false;
            }

            window.addEventListener('keydown', keyDownListener);
            window.addEventListener('keyup', keyUpListener);
            window.addEventListener('mousedown', mouseDownListener);
            window.addEventListener('mouseup', mouseUpListener);

            window.addEventListener('wheel', function(event) {
                if (event.deltaY < 0) {
                    scrollDirection = -1;
                } else if (event.deltaY > 0) {
                    scrollDirection = 1;
                }
            });

            resumeBtn.addEventListener('click', resume);
            settingsBtn.addEventListener('click', () => {
                pauseDefault.style.display = 'none';
                settingsMenu.style.display = null;
                controlsList.style.display = 'none';
            });

            controlsBtn.addEventListener('click', () => {
                pauseDefault.style.display = 'none';
                settingsMenu.style.display = 'none';
                controlsList.style.display = null;
            });

            restartBtn.addEventListener('click', () => {
                location.reload();
            });

            backBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    settingsMenu.style.display = 'none';
                    pauseDefault.style.display = null;
                    controlsList.style.display = 'none';
                });
            });
        }

        function createPlayer() {
            playerMaterial = slipMaterial;

            playerShape = new CANNON.Sphere(0.1)

            playerBody = new CANNON.Body({ mass: 5 })
            playerBody.addShape(playerShape, new CANNON.Vec3(0, 0, 0))
            playerBody.isPlayer = true
            playerBody.collisionFiltergroup = PLAYER_GROUP
            playerBody.collisionFilterMask = EVERYTHING_ELSE_GROUP
            player.playerBody = playerBody
            // playerBody.fixedRotation = true
            // playerBody.updateMassProperties()

            
            playerBody.position.set(0, 0, -5)
            
            playerBody.linearDamping = 0.9
            playerBody.angularDamping = 0.99
            playerBody.allowSleep = false

            player.crouching = false;
            
            world.addBody(playerBody)


            player.anim.grabDest.body = new CANNON.Body({ mass: 0, collisionResponse: false})
            player.anim.grabDest.body.addShape(new CANNON.Box(new CANNON.Vec3(0.01, 0.01, 0.01)))
            player.anim.grabDest.body.position.set(0, 0, 0)
            world.addBody(player.anim.grabDest.body)
        }

        // animation

        player.isJumping = false;
        let accumulatedTime = 0;

        function animate() {
            if(isPaused) return;
            // console.log(dt)
            // console.log(controls.enabled)

            if (controls.enabled) {
                
           
                const time = (performance.now() - pausedTime) / 1000
                const dt = time - lastCallTime
                lastCallTime = time

                // accumulatedTime += dt;

                // timeStep = (1 / (1/dt)) < 1/30 ? 1 / (1/dt) : 1/30;
                // console.log(accumulatedTime >= timeStep, accumulatedTime, timeStep)

                for (const [body, mesh] of meshMap) {
                    body.mesh = mesh;
                    mesh.position.copy(body.position);
                    mesh.quaternion.copy(body.quaternion);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                }

                
                
                mixers.forEach(mixer => mixer.update(dt))

                updateSunPosition(lastCallTime);

                // if(player.currentAction.time >= 1) {
                //     player.currentAction.stop();
                //     player.currentAction = null;
                // }

                // updateSunPosition(time)

                // cubeCamera.update(renderer, scene)

                // spotLightHelper.update()

                // sunHelper.update()

                if(keys['KeyL']) {
                    spotLight.intensity = spotLight.intensity === 0 ? 10 : 0;
                    keys['KeyL'] = false;
                }
                if(keys['KeyE']) {
                    grabObjectCheck(grabBody);
                    keys['KeyE'] = false;
                }

                if(keys['KeyF']) {
                    if(player.equipped === null) {
                        if(grabbedObject && grabbedObject.parent && grabbedObject.parent.equip) {
                            equip(grabbedObject);
                        } else {
                            if(player.equipTest) {
                                equip(player.equipTest);
                            }
                        }
                        keys['KeyF'] = false; 
                    } else if(player.equipped) {
                        player.equipped.unequip();
                        keys['KeyF'] = false;
                    }
                }

                if(keys['KeyC']) {
                    console.log(controls.velocityFactor)
                    player.crouching = !player.crouching;
                    controls.isCrouching = player.crouching;
                    
                    keys['KeyC'] = false;
                }

                if(keys['Space']) {
                    // console.log(controls.isJumping, controls.jumpPreload)
                    if(controls.isJumping) {
                        controls.jumpPreload = true;
                    }

                } else {
                    controls.jumpPreload = false;

                }

                if(mouse[0]) {
                    if(player.equipped) {
                        player.equipped.click();
                        // mouse[0] = false;
                    }
                }
                
                if(mouse[2]) {
                    if(player.equipped) {
                        player.equipped.rightClick();
                    }
                } else {
                    if(player.equipped) {
                        player.equipped.grabPosition = player.equipped.grabReset;
                        if(player.equipped.adsConstraint) {
                            world.removeConstraint(player.equipped.adsConstraint);
                            player.equipped.adsConstraint = null;
                        }
                        player.equipped.recoilMult = player.equipped.recoilMultDefault
                    }
                }

                if(listener != null) {
                    if(controls.moveForward || controls.moveBackward || controls.moveLeft || controls.moveRight) {
                        // console.log(controls.isJumping)
                        if(!controls.isJumping) {
                            stepSound.isPlaying ? null : stepSound.play();
                        } 
                    }
                }
                

                player.pitchObject.position.y = player.crouching ? Math.max(player.pitchObject.position.y - 0.01, 1) : Math.min(player.pitchObject.position.y + 0.01, 1.5);

                if(playerBody.velocity.y <= 0 && playerBody.velocity.y >= -50) {
                    playerBody.velocity.y -= 0.1 * (Math.abs(playerBody.velocity.y) /4);
                }
            

                outlineRaycast();
                
                moveGrabbedObject()

                holdEquipped();

                // createDebugSphere(player.anim.grabDest.getWorldPosition(new THREE.Vector3()), 0.1, 0x00ff00);


            
                player.anim.grabDest.body.position.copy(player.anim.grabDest.getWorldPosition(new THREE.Vector3()))
                player.anim.grabDest.body.quaternion.copy(player.anim.grabDest.getWorldQuaternion(new THREE.Quaternion()))
                player.anim.grabDest.body.velocity.copy(playerBody.velocity)

                yawBody.position.copy(player.pitchObject.getWorldPosition(new THREE.Vector3()));
                yawBody.quaternion.copy(player.pitchObject.getWorldQuaternion(new THREE.Quaternion()));
                yawBody.velocity.copy(playerBody.velocity);

                const playerPitchRotation = player.yawObject.rotation;

                yawBody.quaternion.setFromEuler(0, playerPitchRotation.y, 0, 'XYZ');

                const forwardQuaternion = new CANNON.Quaternion();
                forwardQuaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), Math.PI);
                yawBody.quaternion = yawBody.quaternion.mult(forwardQuaternion);

                const horizontalQuaternion = new CANNON.Quaternion();
                horizontalQuaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
                yawBody.quaternion = yawBody.quaternion.mult(horizontalQuaternion);

                //we want to move the player.hand in and out with the scroll wheel
                if(scrollDirection !== 0) {
                    player.hand.position.z > -50 ? player.hand.position.z += scrollDirection : player.hand.position.z = -50;
                    console.log(player.hand.position.z)
                    // if(player.hand.position.z > 0) player.hand.position.z = -1;
                    if(player.hand.position.z >= -1) player.hand.position.z = -1;
                    scrollDirection = 0;
                    
                }

                handBody.position.copy(player.hand.getWorldPosition(new THREE.Vector3()));
                handBody.velocity.copy(playerBody.velocity);

            

                starMesh.position.copy(controls.getObject().position);

                

                controls.update(dt)
                controls.quaternion.normalize()
                // renderer.render(scene, camera)

                // accumulatedTime = 0;

                

                world.step(timeStep, dt)
                cannonDebugger.update()

                currentRenderer === renderer ? renderer.render(scene, camera) : composer.render()
                
                stats.update()

                
                // console.log(1/dt)
            }
        }

        function getCameraFacing() {
            const euler = new THREE.Euler(controls.pitchObject.rotation.x, controls.yawObject.rotation.y, 0, 'YXZ');
            const quaternion = new THREE.Quaternion().setFromEuler(euler);
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(quaternion);
            return direction;
        }

        function playerRaycast(fromLocation, distance = 10) {
            // Create a direction vector
            // const direction = getCameraFacing();
            const direction = camera.getWorldDirection(new THREE.Vector3());

            // Get the camera's world position
            // const cameraPosition = new THREE.Vector3();
            // controls.getObject().children[0].children[0].getWorldPosition(cameraPosition);
            
            // Create a ray starting from the player position
            const cannonDirection = new CANNON.Vec3(direction.x, direction.y, direction.z);
            const from = new CANNON.Vec3(fromLocation.x, fromLocation.y, fromLocation.z);
            const to = from.vadd(cannonDirection.scale(distance));
        
            // Draw a line from the player's position in the direction they're facing
            // const lineGeometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(from.x, from.y, from.z), new THREE.Vector3(to.x, to.y, to.z)]);
            // const lineMaterial = new THREE.LineBasicMaterial({color: 0xff0000});
            // const line = new THREE.Line(lineGeometry, lineMaterial);
            // scene.add(line);
        
            // // // Remove the line after a certain amount of time
            // setTimeout(() => scene.remove(line), 500);            

            const result = new CANNON.RaycastResult();
            world.raycastClosest(from, to, {collisionFilterMask: EVERYTHING_ELSE_GROUP, skipBackfaces: false}, result);
            
            player.result = result;

            return result;
        }

        let castBody = null;

        function outlineRaycast() {
          
            let cameraPosition = new THREE.Vector3();
            controls.getObject().children[0].children[0].getWorldPosition(cameraPosition);
            
            // createDebugSphere(cameraPosition, 1000, 0x00ff00);

            let cast = playerRaycast(cameraPosition, 100);

           
            castBody = cast.body;

            if(castBody && castBody.mass === 0) {
                outlinePass.selectedObjects = [];
                grabBody = null;
                grabbedObject === null ? setCrosshair('look') : setCrosshair('grab');
                return;
            }
            let castMesh = meshMap.get(castBody);

            if(castMesh) {
                outlinePass.selectedObjects = [castMesh];
                grabBody = castBody;
                grabBody.cast = cast;
                equipTest(castBody);
            } else {
                outlinePass.selectedObjects = [];
                grabBody = null;
                grabbedObject === null ? setCrosshair('look') : setCrosshair('grab');
            }
        }

        function grabObjectCheck(body) {
            if(player.equipped && body === null) return;
            if(player.equipped && body !== player.equipped.body && body !== null) player.equipped.unequip();

            if(body === null) {grabbedObject = null; isGrabbing = false; removegrabConstraint(); world.removeConstraint(player.handConstraint); return;}
            if(body.mass === 0) return;
            
            if(grabbedObject) {
                //release object
                if(grabbedObject === body) {
                    grabbedObject = null;
                    isGrabbing = false;
                    removegrabConstraint();
                    world.removeConstraint(player.handConstraint);
                } else {
                    //grab object
                    grabbedObject = body;
                    isGrabbing = true;
                    // player.hand.position.z = -grabBody.cast.distance;
                    // console.log(grabBody.cast.distance, player.hand)
                    removegrabConstraint();

                    addJointConstraint(grabBody.cast.hitPointWorld, grabbedObject);
                    moveJoint(grabBody.cast.distance);

                    world.addConstraint(player.handConstraint);
                }
            } else {
                //grab object
                grabbedObject = body;
                isGrabbing = true;
                // player.hand.position.z = -grabBody.cast.distance;
                // console.log(grabBody.cast, player.hand)
                removegrabConstraint();
                
                addJointConstraint(grabBody.cast.hitPointWorld, grabbedObject);
                moveJoint(grabBody.cast.distance);

                world.addConstraint(player.handConstraint);

            }
            console.log(grabbedObject, isGrabbing);
        }

        function createDebugSphere(position, timeout = 5000) {
            const sphereGeometry = new THREE.SphereGeometry(0.15, 32, 32);
            const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphereMesh.position.copy(position);
            scene.add(sphereMesh);

            setTimeout(() => {
                scene.remove(sphereMesh);
            }, timeout);
        }

        function createDebugLine(from, to, color = 0xff0000, timeout = 5000) {
            const lineGeometry = new THREE.BufferGeometry().setFromPoints([from, to]);
            const lineMaterial = new THREE.LineBasicMaterial({color: color});
            const line = new THREE.Line(lineGeometry, lineMaterial);
            scene.add(line);

            setTimeout(() => {
                scene.remove(line);
            }, timeout);
        }

        let constrained = [];

        function addJointConstraint(position, constrainedBody) {
            constrainedBody.originalDampingA = constrainedBody.angularDamping;
            constrainedBody.originalDampingL = constrainedBody.linearDamping;
            constrainedBody.linearDamping = 0.999;
            constrainedBody.angularDamping = 0.999;

            constrained.push(constrainedBody);

            // Vector that goes from the body to the clicked point
            const vector = new CANNON.Vec3().copy(position).vsub(constrainedBody.position)

            // Apply anti-quaternion to vector to tranform it into the local body coordinate system
            const antiRotation = constrainedBody.quaternion.inverse()
            const pivot = antiRotation.vmult(vector) // pivot is not in local body coordinates

            // Move the cannon click marker body to the click position
            handBody.position.copy(position)

            // Create a new constraint
            // The pivot for the jointBody is zero
            grabConstraint = new CANNON.PointToPointConstraint(constrainedBody, pivot, handBody, new CANNON.Vec3(0, 0, 0))

            // Add the constraint to world
            world.addConstraint(grabConstraint)
        }

        // This functions moves the joint body to a new postion in space
        // and updates the constraint
        function moveJoint(position) {
            player.hand.position.z = -position
            grabConstraint.update()
        }

        // Remove constraint from world
        function removegrabConstraint() {
            world.removeConstraint(grabConstraint)
            grabConstraint = undefined
            constrained.forEach(body => {
                body.angularDamping = body.originalDampingA;
                body.linearDamping = body.originalDampingL;
                constrained = constrained.filter(b => b !== body);
            });
        }

        function equipTest(body) {
            if(body === null) return;
            if(body.mass === 0) return;
            if(player.equipped) return;
            if(body.parent && body.parent.equip) {
                setCrosshair('interact');
                player.equipTest = body;
            } else {
                setCrosshair('grab');
                player.equipTest = null;
            }
        }

        function moveGrabbedObject() {
            if(grabbedObject) {
                if(grabbedObject.parent && grabbedObject.parent.equip) {
                    setCrosshair('interact');
                }
                // let destination = player.hand.getWorldPosition(new THREE.Vector3());
                // //add grabDest to destination relative to camerafacing
                // destination.add(getCameraFacing().multiplyScalar(-player.grabDest.z));

                
                // // console.log(destination)
                // //subtract the difference between the object position and the destination
                // let difference = new CANNON.Vec3(destination.x - grabbedObject.position.x, destination.y - grabbedObject.position.y, destination.z - grabbedObject.position.z);
                // grabbedObject.wakeUp();
                // grabbedObject.angularVelocity.set(0, 0, 0);
                // grabbedObject.velocity.set(0, 0, 0);
                // // grabbedObject.position.set(destination.x, destination.y, destination.z);
                // grabbedObject.velocity.set(difference.x, difference.y, difference.z);
                // // console.log(difference)
                // player.handConstraint.update();
               
                
                //only apply force in sync with timestep
                // console.log(dt, timeStep)

                // accumulatedTime += dt;

                // if(accumulatedTime >= timeStep) {
                //     player.handConstraint.applyForce();
                //     accumulatedTime = 0;
                // }

                
            }
        }

        async function loadGLTF(url, scale) {
            const loader = new GLTFLoader();
            return new Promise((resolve, reject) => {

                loader.load(url, function (gltf) {
                    // gltf.scene.scale.set(0.9, 0.9, 0.9);
                    

                    gltf.scene.traverse( function ( child ) {
                        if(child.isLight) {
                            child.castShadow = true;
                            child.shadow.bias = -0.0001;
                            child.shadow.mapSize.width = 1024;
                            child.shadow.mapSize.height = 1024;
                            child.shadow.camera.near = 0.5;
                            child.shadow.camera.far = 500;
                        }

                        if ( child.isMesh ) {
                            if (child.material.isMeshStandardMaterial) {
                                // console.log(child.material);
                                // child.material.metalness = 0;
                                // child.material.roughness = 0.5;
                                // child.material.envMapIntensity = globalEnvMapIntensity;
                                // matList.push(child.material);
                            } else if (Array.isArray(child.material)) {
                                child.material.forEach(mat => {
                                    if (mat.isMeshStandardMaterial) {
                                        // mat.metalness = 0;
                                        // mat.roughness = 0.5;
                                        // mat.envMapIntensity = globalEnvMapIntensity;
                                        // matList.push(mat);
                                    }
                                });
                            }
                            child.castShadow = true;
                            child.receiveShadow = true;                       

                            let shapeType;
                            switch (child.userData.shapeType) {
                                case 'SPHERE':
                                    shapeType = ShapeType.SPHERE;
                                    sphereCollision(child, gltf.scene, child.userData.radius || 0.5);
                                    break;
                                case 'BOX':
                                    shapeType = ShapeType.BOX;
                                    boxCollision(child, gltf.scene, child.userData.size);
                                    break;
                                case 'CYLINDER':
                                    shapeType = ShapeType.CYLINDER;
                                    cylinderCollision(child, gltf.scene, child.userData.radiusTop, child.userData.radiusBottom, child.userData.height, child.userData.resolution);
                                    break;
                                case 'HULL':
                                    shapeType = ShapeType.HULL;
                                    hullCollision(child, gltf.scene);
                                    break;
                                case 'MESH':
                                    shapeType = ShapeType.MESH;
                                    meshCollision(child, gltf.scene);
                                    break;
                                default:
                                    //no collision
                                break;
                            }
                        }
                    });

                    resolve(gltf);
                }, undefined, function (error) {
                    // Reject the promise if there's an error
                    reject(error);
                });
            });

        }

        function sphereCollision(child, scene, radius) {
            let sphereBody = new CANNON.Body({
                mass: child.userData.mass || 0, 
                collisionFilterGroup: EVERYTHING_ELSE_GROUP,
                collisionFilterMask: PLAYER_GROUP | EVERYTHING_ELSE_GROUP,});
            let sphere = new CANNON.Sphere(radius);
            sphereBody.addShape(sphere);
            sphereBody.position.set(child.position.x, child.position.y, child.position.z);
            world.addBody(sphereBody);
            if(child.name.endsWith('noDraw')) {
                scene.remove(child);
            } else {
                meshMap.set(sphereBody, child);
            }
        }

        function boxCollision(child, scene, size) {
            let boxBody = new CANNON.Body({
                mass: child.userData.mass || 0,
                collisionFilterGroup: EVERYTHING_ELSE_GROUP,
                collisionFilterMask: PLAYER_GROUP | EVERYTHING_ELSE_GROUP,
            });
            let dimensions;
            if(size !== undefined) {
                dimensions = new CANNON.Vec3(size.x, size.y, size.z);
            } else {
                //get dimensions from mesh
                let box = new THREE.Box3().setFromObject(child);
                dimensions = new CANNON.Vec3((box.max.x - box.min.x)/2, (box.max.y - box.min.y)/2, (box.max.z - box.min.z)/2);
            }
            let box = new CANNON.Box(dimensions);
            boxBody.addShape(box);
            boxBody.position.set(child.position.x, child.position.y, child.position.z);
            world.addBody(boxBody);
            if(child.name.endsWith('noDraw')) {
                scene.remove(child);
            } else {
                meshMap.set(boxBody, child);
            }
        }

        function cylinderCollision(child, scene, radiusTop, radiusBottom, height, resolution) {
            let cylinderBody = new CANNON.Body({
                mass: child.userData.mass || 0,
                collisionFilterGroup: EVERYTHING_ELSE_GROUP,
                collisionFilterMask: PLAYER_GROUP | EVERYTHING_ELSE_GROUP,
            });
            radiusTop = radiusTop ? radiusTop : radiusBottom ? radiusBottom : 0.5;
            radiusBottom = radiusBottom ? radiusBottom : radiusTop ? radiusTop : 0.5;
            let cylinder = new CANNON.Cylinder(radiusTop, radiusBottom, height, resolution);
            cylinderBody.addShape(cylinder);
            cylinderBody.position.set(child.position.x, child.position.y, child.position.z);
            world.addBody(cylinderBody);
            if(child.name.endsWith('noDraw')) {
                scene.remove(child);
            } else {
                meshMap.set(cylinderBody, child);
            }
        }

        function hullCollision(child, scene) {
            let hullType = child.userData.hullType || 'mesh';
            let hullBody = new CANNON.Body({
                mass: child.userData.mass || 0,
                collisionFilterGroup: EVERYTHING_ELSE_GROUP,
                collisionFilterMask: PLAYER_GROUP | EVERYTHING_ELSE_GROUP,
            });
            let shape;
            switch(hullType) {
                case 'mesh':
                    //create hull from mesh
                    shape = threeToCannon(child, {type: ShapeType.HULL});
                    
                    
                    hullBody.addShape(shape.shape);
                break;
                case 'colobject':
                    //create hull from child with name ending in .col
                    let colMesh = child.children.filter(child => child.name.endsWith('col'))[0];
                    console.log(colMesh);
                    shape = threeToCannon(colMesh, {type: ShapeType.HULL});
                    hullBody.addShape(shape.shape, shape.offset, shape.orientation);
                    child.remove(colMesh);
                break;
                case 'vhacd':
                    //child has many children, each a convex hull
                    //they will have _hull_ in their name
                    let hulls = child.children.filter(child => child.name.includes('_hull_'));
                    hulls.forEach(hull => {
                        // hull position is (5.82892, -0.193318, -0.683173);
                        //offset should be the difference between the child and the hull object
                        let offset = new CANNON.Vec3(
                            hull.position.x + child.position.x,
                            hull.position.y + child.position.y,
                            hull.position.z + child.position.z
                        );
                        offset = offset.vsub(child.position);
                        let hullShape = threeToCannon(hull, {type: ShapeType.HULL});
                        hullBody.addShape(hullShape.shape, offset);
                        child.remove(hull);
                    });
                    
                break;
            }
            hullBody.position.set(child.position.x, child.position.y, child.position.z);
            hullBody.quaternion.set(child.quaternion.x, child.quaternion.y, child.quaternion.z, child.quaternion.w);
            world.addBody(hullBody);
            if(child.name.endsWith('noDraw')) {
                scene.remove(child);
            } else {
                meshMap.set(hullBody, child);
            }
        }

        const wheels = [];
        
        async function carSetup() {
            //car setup

            //materials

            const bodyMaterial = new THREE.MeshPhysicalMaterial( {
                color: 0xff0000, metalness: 1.0, roughness: 0.5, clearcoat: 1.0, clearcoatRoughness: 0.03
            } );

            const detailsMaterial = new THREE.MeshStandardMaterial( {
                color: 0xffffff, metalness: 1.0, roughness: 0.5
            } );

            const glassMaterial = new THREE.MeshPhysicalMaterial( {
                color: 0xffffff, metalness: 0.25, roughness: 0, transmission: 1.0
            } );

            const emissiveMaterial = new THREE.MeshStandardMaterial( {
                color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 10.0, metalness: 1.0, roughness: 0.5
            } );

            let ferrari = await loadGLTF('assets/ferrari2.glb', 1)
            scene.add(ferrari.scene);
            

            const carModel = ferrari.scene

            carModel.getObjectByName( 'body' ).material = bodyMaterial;

            carModel.getObjectByName( 'rim_fl' ).material = detailsMaterial;
            carModel.getObjectByName( 'rim_fr' ).material = detailsMaterial;
            carModel.getObjectByName( 'rim_rr' ).material = detailsMaterial;
            carModel.getObjectByName( 'rim_rl' ).material = detailsMaterial;
            carModel.getObjectByName( 'trim' ).material = detailsMaterial;

            carModel.getObjectByName( 'glass' ).material = glassMaterial;

            wheels.push(
                carModel.getObjectByName( 'wheel_fl' ),
                carModel.getObjectByName( 'wheel_fr' ),
                carModel.getObjectByName( 'wheel_rl' ),
                carModel.getObjectByName( 'wheel_rr' )
            );
        }


        async function ragdollSetup(isPlayer = false, scale = 1, mass = 1) {
            const { bodies, constraints } = createRagdoll({
                scale: scale,
                angle: Math.PI / 2,
                angleShoulders: Math.PI / 3,
                twistAngle: Math.PI / 2,
                mass: mass,
            })

            bodies.forEach((body) => {
                // Move the ragdoll up
                body.allowSleep = false
                body.linearDamping = 0.99
                body.angularDamping = 0.99
                if(isPlayer) {
                    body.collisionFiltergroup = PLAYER_GROUP
                    body.collisionFilterMask = EVERYTHING_ELSE_GROUP
                }
                world.addBody(body)
            })

            constraints.forEach((constraint) => {
                world.addConstraint(constraint)
            })

            console.log(bodies)

            // let gloveLeftScene = await loadGLTF('assets/glove1.glb', 1)
            // let gloveLeft = gloveLeftScene.scene.children[0];
            // console.log(gloveLeft)
            // scene.add(gloveLeftScene.scene);
            // gloveLeft.position.set(0, 0, 0);
            // gloveLeft.scale.set(0.2, 0.2, 0.2);
            // meshMap.set(player.lowerLeftArm, gloveLeft);

            // let gloveRight = gloveLeft.clone();
            // gloveRight.position.set(0, 0, 0);
            // gloveRight.scale.set(-0.2, 0.2, 0.2);
            // scene.add(gloveRight);
            // meshMap.set(player.lowerRightArm, gloveRight);

            let bootLeftScene = await loadGLTF('assets/boot1.glb', 1);
            let bootLeft = bootLeftScene.scene.children[0];
            bootLeft.position.set(0, 0, 0);
            bootLeft.scale.set(0.4, 0.4, -0.4);
            scene.add(bootLeftScene.scene);
            meshMap.set(player.lowerLeftLeg, bootLeft);

            let bootRight = bootLeft.clone();
            bootRight.position.set(0, 0, 0);
            bootRight.scale.set(-0.4, 0.4, -0.4);
            scene.add(bootRight);
            meshMap.set(player.lowerRightLeg, bootRight);

            let upperLeftArmScene = await loadGLTF('assets/upperarm1.glb', 1);
            let upperLeftArm = upperLeftArmScene.scene.children[0];
            upperLeftArm.position.set(0, 0, 0);
            upperLeftArm.scale.set(-0.3, 0.3, -0.3);
            scene.add(upperLeftArmScene.scene);
            meshMap.set(player.upperLeftArm, upperLeftArm);

            let upperRightArm = upperLeftArm.clone();
            upperRightArm.position.set(0, 0, 0);
            upperRightArm.scale.set(0.3, 0.3, -0.3);
            scene.add(upperRightArm);
            meshMap.set(player.upperRightArm, upperRightArm);

            let ragdollChestBody = bodies.find(body => body.name === 'upperBody')
            //rotate to face opposite y
            // ragdollChestBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), Math.PI)


            console.log(ragdollChestBody)
            let localPivotPlayer = new CANNON.Vec3(0, 0.05, -0.3)
            let localPivotRagdoll = new CANNON.Vec3(0, 0, 0)
            let constraint = new CANNON.ConeTwistConstraint(yawBody, ragdollChestBody, {
                pivotA: localPivotPlayer,
                pivotB: localPivotRagdoll,
                axisA: new CANNON.Vec3(0, 1, 0),
                axisB:  new CANNON.Vec3(0, 1, 0),
                angle: 0,
                twistAngle: 0,
                
            })
            world.addConstraint(constraint)

            // we make a spring from handBody to the ragdoll's hand that we can activate when we want to grab something
            let ragdollHand = bodies.find(body => body.name === 'hand')
            player.ragdollHand = ragdollHand

            let ragdollLeftHand = bodies.find(body => body.name === 'leftHand')
            player.ragdollLeftHand = ragdollLeftHand
            
            if(isPlayer) {
                const handConstraint = new CANNON.DistanceConstraint(player.ragdollHand, player.anim.grabDest.body, 0.1, 0.01)
                player.resetHandConstraint = handConstraint;
                player.handConstraint = handConstraint;
            }
            

        }

        function createRagdoll({ scale = 1, angle, angleShoulders, twistAngle, mass = 1}) {
            const bodies = []
            const constraints = []

            let ragdollMeshMaterial = function() {
                let randomColour = Math.floor(Math.random()*(0xffffff - 0xaaaaaa) + 0xaaaaaa).toString(16);
                return new THREE.MeshStandardMaterial({
                    color: `#${randomColour}`,
                    metalness: 0.1,
                    roughness: 0.5,
                });
            }

            const shouldersDistance = 0.5 * scale
            const upperArmLength = 0.4 * scale
            const lowerArmLength = 0.4 * scale
            const upperArmSize = 0.1 * scale
            const lowerArmSize = 0.1 * scale
            const neckLength = 0.1 * scale
            const headRadius = 0.25 * scale
            const handRadius = 0.1 * scale
            const upperBodyLength = 0.6 * scale
            const pelvisLength = 0.4 * scale
            const upperLegLength = 0.5 * scale
            const upperLegSize = 0.2 * scale
            const lowerLegSize = 0.15 * scale
            const lowerLegLength = 0.5 * scale

            const headShape = new CANNON.Sphere(headRadius)
            const upperArmShape = new CANNON.Box(
            new CANNON.Vec3(upperArmLength * 0.5, upperArmSize * 0.5, upperArmSize * 0.5)
            )
            const lowerArmShape = new CANNON.Box(
            new CANNON.Vec3(lowerArmLength * 0.5, lowerArmSize * 0.5, lowerArmSize * 0.5)
            )
            const handShape = new CANNON.Sphere(handRadius)
            const upperBodyShape = new CANNON.Box(
            new CANNON.Vec3(shouldersDistance * 0.5, lowerArmSize * 0.5, upperBodyLength * 0.5)
            )
            const pelvisShape = new CANNON.Box(
            new CANNON.Vec3(shouldersDistance * 0.5, lowerArmSize * 0.5, pelvisLength * 0.5)
            )
            const upperLegShape = new CANNON.Box(
            new CANNON.Vec3(upperLegSize * 0.5, lowerArmSize * 0.5, upperLegLength * 0.5)
            )
            const lowerLegShape = new CANNON.Box(
            new CANNON.Vec3(lowerLegSize * 0.5, lowerArmSize * 0.5, lowerLegLength * 0.5)
            )

            // Lower legs
            const lowerLeftLeg = new CANNON.Body({
            mass: mass,
            position: new CANNON.Vec3(shouldersDistance / 2, 0, lowerLegLength / 2),
            })
            const lowerRightLeg = new CANNON.Body({
            mass: mass,
            position: new CANNON.Vec3(-shouldersDistance / 2, 0, lowerLegLength / 2),
            })
            lowerLeftLeg.addShape(lowerLegShape)
            lowerRightLeg.addShape(lowerLegShape)
            bodies.push(lowerLeftLeg)
            bodies.push(lowerRightLeg)

            player.lowerLeftLeg = lowerLeftLeg;
            player.lowerRightLeg = lowerRightLeg;
            // let lowerLeftLegMesh = new THREE.Mesh(new THREE.BoxGeometry(lowerLegSize, lowerLegSize, lowerLegLength), ragdollMeshMaterial());
            // let lowerRightLegMesh = new THREE.Mesh(new THREE.BoxGeometry(lowerLegSize, lowerLegSize, lowerLegLength), ragdollMeshMaterial());
            // scene.add(lowerLeftLegMesh);
            // scene.add(lowerRightLegMesh);
            // meshMap.set(lowerLeftLeg, lowerLeftLegMesh);
            // meshMap.set(lowerRightLeg, lowerRightLegMesh);

            // Upper legs
            const upperLeftLeg = new CANNON.Body({
            mass: mass,
            position: new CANNON.Vec3(
                shouldersDistance / 2,
                0,
                lowerLeftLeg.position.z + lowerLegLength / 2 + upperLegLength / 2
            ),
            })
            const upperRightLeg = new CANNON.Body({
            mass: mass,
            position: new CANNON.Vec3(
                -shouldersDistance / 2,
                0,
                lowerRightLeg.position.z + lowerLegLength / 2 + upperLegLength / 2
            ),
            })
            upperLeftLeg.addShape(upperLegShape)
            upperRightLeg.addShape(upperLegShape)
            bodies.push(upperLeftLeg)
            bodies.push(upperRightLeg)
            let upperLeftLegMesh = new THREE.Mesh(new THREE.BoxGeometry(upperLegSize, lowerLegSize, upperLegLength), ragdollMeshMaterial());
            let upperRightLegMesh = new THREE.Mesh(new THREE.BoxGeometry(upperLegSize, lowerLegSize, upperLegLength), ragdollMeshMaterial());
            scene.add(upperLeftLegMesh);
            scene.add(upperRightLegMesh);
            meshMap.set(upperLeftLeg, upperLeftLegMesh);
            meshMap.set(upperRightLeg, upperRightLegMesh);

            // Pelvis
            const pelvis = new CANNON.Body({
            mass: mass,
            position: new CANNON.Vec3(0, 0, upperLeftLeg.position.z + upperLegLength / 2 + pelvisLength / 2),
            })
            pelvis.addShape(pelvisShape)
            bodies.push(pelvis)
            // let pelvisMesh = new THREE.Mesh(new THREE.BoxGeometry(shouldersDistance, lowerArmSize, pelvisLength), ragdollMeshMaterial());
            // scene.add(pelvisMesh);
            // meshMap.set(pelvis, pelvisMesh);


            // Upper body
            const upperBody = new CANNON.Body({
            mass: mass,
            position: new CANNON.Vec3(0, 0, pelvis.position.z + pelvisLength / 2 + upperBodyLength / 2),
            })
            upperBody.addShape(upperBodyShape)
            upperBody.name = 'upperBody';
            bodies.push(upperBody)
            //make it vertical
            // upperBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.PI / 2)

            // let upperBodyMesh = new THREE.Mesh(new THREE.BoxGeometry(shouldersDistance, lowerArmSize, upperBodyLength), ragdollMeshMaterial());
            // scene.add(upperBodyMesh);
            // meshMap.set(upperBody, upperBodyMesh);

            // Head
            // const head = new CANNON.Body({
            // mass: mass,
            // position: new CANNON.Vec3(0, 0, upperBody.position.z + upperBodyLength / 2 + headRadius + neckLength),
            // })
            // head.addShape(headShape)
            // head.name = 'head';
            // bodies.push(head)
            // let headMesh = new THREE.Mesh(new THREE.SphereGeometry(headRadius), ragdollMeshMaterial());
            // scene.add(headMesh);
            // meshMap.set(head, headMesh);

            // Upper arms
            const upperLeftArm = new CANNON.Body({
            mass: mass,
            position: new CANNON.Vec3(
                shouldersDistance / 2 + upperArmLength / 2,
                0,
                upperBody.position.z + upperBodyLength / 2
            ),
            })
            const upperRightArm = new CANNON.Body({
            mass: mass,
            position: new CANNON.Vec3(
                -shouldersDistance / 2 - upperArmLength / 2,
                0,
                upperBody.position.z + upperBodyLength / 2
            ),
            })
            upperLeftArm.addShape(upperArmShape)
            upperRightArm.addShape(upperArmShape)
            bodies.push(upperLeftArm)
            bodies.push(upperRightArm)
            player.upperLeftArm = upperLeftArm;
            player.upperRightArm = upperRightArm;
            // let upperLeftArmMesh = new THREE.Mesh(new THREE.BoxGeometry(upperArmLength, upperArmSize, upperArmSize), ragdollMeshMaterial());
            // let upperRightArmMesh = new THREE.Mesh(new THREE.BoxGeometry(upperArmLength, upperArmSize, upperArmSize), ragdollMeshMaterial());
            // scene.add(upperLeftArmMesh);
            // scene.add(upperRightArmMesh);
            // meshMap.set(upperLeftArm, upperLeftArmMesh);
            // meshMap.set(upperRightArm, upperRightArmMesh);

            // Lower arms
            const lowerLeftArm = new CANNON.Body({
            mass: mass,
            position: new CANNON.Vec3(
                upperLeftArm.position.x + lowerArmLength / 2 + upperArmLength / 2,
                0,
                upperLeftArm.position.z
            ),
            })
            const lowerRightArm = new CANNON.Body({
            mass: mass,
            position: new CANNON.Vec3(
                upperRightArm.position.x - lowerArmLength / 2 - upperArmLength / 2,
                0,
                upperRightArm.position.z
            ),
            })
            lowerLeftArm.addShape(lowerArmShape)
            lowerRightArm.addShape(lowerArmShape)
            bodies.push(lowerLeftArm)
            bodies.push(lowerRightArm)
            player.lowerLeftArm = lowerLeftArm;
            player.lowerRightArm = lowerRightArm;
            let lowerLeftArmMesh = new THREE.Mesh(new THREE.BoxGeometry(lowerArmLength, lowerArmSize, lowerArmSize), ragdollMeshMaterial());
            let lowerRightArmMesh = new THREE.Mesh(new THREE.BoxGeometry(lowerArmLength, lowerArmSize, lowerArmSize), ragdollMeshMaterial());
            scene.add(lowerLeftArmMesh);
            scene.add(lowerRightArmMesh);
            meshMap.set(lowerLeftArm, lowerLeftArmMesh);
            meshMap.set(lowerRightArm, lowerRightArmMesh);

            //Hands
            let leftHand = new CANNON.Body({
                mass: mass,
                position: new CANNON.Vec3(
                    lowerLeftArm.position.x + lowerArmLength,
                    0,
                    lowerLeftArm.position.z
                ),
            });
            let rightHand = new CANNON.Body({
                mass: mass,
                position: new CANNON.Vec3(
                    lowerRightArm.position.x - lowerArmLength,
                    0,
                    lowerRightArm.position.z
                ),
            });
            leftHand.addShape(handShape);
            rightHand.addShape(handShape);
            bodies.push(leftHand);
            bodies.push(rightHand);
            rightHand.name = 'hand';
            leftHand.name = 'leftHand';

            player.leftHand = leftHand;
            player.rightHand = rightHand;
            let leftHandMesh = new THREE.Mesh(new THREE.SphereGeometry(handRadius), ragdollMeshMaterial());
            let rightHandMesh = new THREE.Mesh(new THREE.SphereGeometry(handRadius), ragdollMeshMaterial());
            scene.add(leftHandMesh);
            scene.add(rightHandMesh);
            meshMap.set(leftHand, leftHandMesh);
            meshMap.set(rightHand, rightHandMesh);

            //wrist joints
            let leftWristJoint = new CANNON.ConeTwistConstraint(leftHand, lowerLeftArm, {
                pivotA: new CANNON.Vec3(0, 0, 0),
                pivotB: new CANNON.Vec3(lowerArmLength, 0, 0),
                axisA: CANNON.Vec3.UNIT_X,
                axisB: CANNON.Vec3.UNIT_X,
                angle: Math.PI,
                twistAngle: Math.PI,
            });
            constraints.push(leftWristJoint);

            let rightWristJoint = new CANNON.ConeTwistConstraint(rightHand, lowerRightArm, {
                pivotA: new CANNON.Vec3(0, 0, 0),
                pivotB: new CANNON.Vec3(-lowerArmLength, 0, 0),
                axisA: CANNON.Vec3.UNIT_X,
                axisB: CANNON.Vec3.UNIT_X,
                angle: Math.PI,
                twistAngle: Math.PI,
            });
            constraints.push(rightWristJoint);
            
            // Neck joint
            // const neckJoint = new CANNON.ConeTwistConstraint(head, upperBody, {
            // pivotA: new CANNON.Vec3(0, 0, -headRadius - neckLength / 2),
            // pivotB: new CANNON.Vec3(0, 0, upperBodyLength / 2),
            // axisA: CANNON.Vec3.UNIT_Z,
            // axisB: CANNON.Vec3.UNIT_Z,
            // angle: 0,
            // twistAngle: Math.PI / 2,
            // })
            // constraints.push(neckJoint)

            // Knee joints
            const leftKneeJoint = new CANNON.ConeTwistConstraint(lowerLeftLeg, upperLeftLeg, {
            pivotA: new CANNON.Vec3(0, 0, lowerLegLength / 2),
            pivotB: new CANNON.Vec3(0, 0, -upperLegLength / 2),
            axisA: CANNON.Vec3.UNIT_Z,
            axisB: CANNON.Vec3.UNIT_Z,
            angle: Math.PI / 2,
            twistAngle: Math.PI / 16,
            })
            const rightKneeJoint = new CANNON.ConeTwistConstraint(lowerRightLeg, upperRightLeg, {
            pivotA: new CANNON.Vec3(0, 0, lowerLegLength / 2),
            pivotB: new CANNON.Vec3(0, 0, -upperLegLength / 2),
            axisA: CANNON.Vec3.UNIT_Z,
            axisB: CANNON.Vec3.UNIT_Z,
            angle: Math.PI / 2,
            twistAngle: Math.PI / 16,
            })
            constraints.push(leftKneeJoint)
            constraints.push(rightKneeJoint)

            // Hip joints
            const leftHipJoint = new CANNON.ConeTwistConstraint(upperLeftLeg, pelvis, {
            pivotA: new CANNON.Vec3(0, 0, upperLegLength / 2),
            pivotB: new CANNON.Vec3(shouldersDistance / 2, 0, -pelvisLength / 2),
            axisA: CANNON.Vec3.UNIT_Z,
            axisB: CANNON.Vec3.UNIT_Z,
            angle: Math.PI / 2,
            twistAngle: Math.PI / 8,
            })
            const rightHipJoint = new CANNON.ConeTwistConstraint(upperRightLeg, pelvis, {
            pivotA: new CANNON.Vec3(0, 0, upperLegLength / 2),
            pivotB: new CANNON.Vec3(-shouldersDistance / 2, 0, -pelvisLength / 2),
            axisA: CANNON.Vec3.UNIT_Z,
            axisB: CANNON.Vec3.UNIT_Z,
            angle: Math.PI / 2,
            twistAngle: Math.PI / 8,
            })
            constraints.push(leftHipJoint)
            constraints.push(rightHipJoint)

            // Spine
            const spineJoint = new CANNON.ConeTwistConstraint(pelvis, upperBody, {
            pivotA: new CANNON.Vec3(0, 0, pelvisLength / 2),
            pivotB: new CANNON.Vec3(0, 0, -upperBodyLength / 2),
            axisA: CANNON.Vec3.UNIT_Z,
            axisB: CANNON.Vec3.UNIT_Z,
            angle: angle / 4,
            twistAngle: twistAngle / 8,
            })
            constraints.push(spineJoint)

            // Shoulders
            const leftShoulder = new CANNON.ConeTwistConstraint(upperBody, upperLeftArm, {
            pivotA: new CANNON.Vec3(shouldersDistance / 2, 0, upperBodyLength / 2),
            pivotB: new CANNON.Vec3(-upperArmLength / 2, 0, 0),
            axisA: CANNON.Vec3.UNIT_X,
            axisB: CANNON.Vec3.UNIT_X,
            angle: Math.PI / 2,
            twistAngle: Math.PI / 2,
            })
            const rightShoulder = new CANNON.ConeTwistConstraint(upperBody, upperRightArm, {
            pivotA: new CANNON.Vec3(-shouldersDistance / 2, 0, upperBodyLength / 2),
            pivotB: new CANNON.Vec3(upperArmLength / 2, 0, 0),
            axisA: CANNON.Vec3.UNIT_X,
            axisB: CANNON.Vec3.UNIT_X,
            angle: Math.PI / 2,
            twistAngle: Math.PI / 2,
            })
            constraints.push(leftShoulder)
            constraints.push(rightShoulder)

            // Elbow joint
            const leftElbowJoint = new CANNON.ConeTwistConstraint(lowerLeftArm, upperLeftArm, {
            pivotA: new CANNON.Vec3(-lowerArmLength / 2, 0, 0),
            pivotB: new CANNON.Vec3(upperArmLength / 2, 0, 0),
            axisA: CANNON.Vec3.UNIT_X,
            axisB: CANNON.Vec3.UNIT_X,
            angle: Math.PI / 2,
            twistAngle: Math.PI/8
            })
            const rightElbowJoint = new CANNON.ConeTwistConstraint(lowerRightArm, upperRightArm, {
            pivotA: new CANNON.Vec3(lowerArmLength / 2, 0, 0),
            pivotB: new CANNON.Vec3(-upperArmLength / 2, 0, 0),
            axisA: CANNON.Vec3.UNIT_X,
            axisB: CANNON.Vec3.UNIT_X,
            angle: Math.PI / 2,
            twistAngle: Math.PI/8
            })
            constraints.push(leftElbowJoint)
            constraints.push(rightElbowJoint)

            // bodies.forEach((body) => {
            //     body.collisionFilterGroup = EVERYTHING_ELSE_GROUP
            //     body.collisionFilterMask = PLAYER_GROUP | EVERYTHING_ELSE_GROUP
            // })

            return { bodies, constraints }
        }

    </script>
</body>
</html>